#from _typeshed import Self
import os
import random
import string
import sys
import logging
import time
from collections import deque
from collections import defaultdict
from .Objects import *
import pickle
import threading
import random
import copy
import os
import multiprocessing
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
import heapq

config(clock='Lamport')
config(handling='all')

TIMEOUT = 1


class Replica(process):
    def setup(replica_id: int, curr_pr, ps: list,rep_map:dict, f: int, number_of_requests: int,replica_public_keys=None,client_public_keys=None,replica_private_key=None):
        # ====== attributes of Replica ======
        output("creating replica ", replica_id)
        self.f = f
        self.replicas = ps
        self.proposals = set()
        self.number_of_requests = number_of_requests
        self.processing_req = False
        self.votes_received = 0
        self.replica_map=rep_map
        random.seed(6)
        # ====== attributes of Main ======

        self.replica_id = replica_id
        self.window_size = 1
        self.replica_id = replica_id
        self.win_sz = 1
        self.curr_pr = curr_pr

        # ====== attributes of MemPool ======
        # self.hq = heapq.heapify([])
        #self.hq = []
        # self.mem_map={}
        self.mem_queue =  []
        # self.lock_1 = threading.Lock()
        # self.lock_pid = multiprocessing.Lock()
        self.test_if_mem_queue_is_full = 0
        # ====== attributes of Ledger ======
        cur_path = os.getcwd()
        self.file_name = os.path.abspath(cur_path + "/../data/Ledger_" + str(self.replica_id) + ".txt")
        self.pending_map = {}
        self.commited_blocks = deque()  # committed block with window size
        self.ledger_state = ""

        # ====== attributes of Safety ======
        self.highest_vote_round = -1
        self.highest_qc_round = -1

        self.private_key = replica_private_key
        self.replica_public_keys = replica_public_keys
        self.client_public_keys = client_public_keys

        # ====== attributes of BlockTree ======

        self.pending_block_tree = set()
        self.pending_votes = defaultdict(list)
        vote_info = VoteInfo(-1, -1, -2, -2)
        ledger_commit_info = LedgerCommitInfo(None, vote_info)
        qc = QC(vote_info, ledger_commit_info)
        genesis_block = Block(0, -1, "", qc)
        self.high_qc = qc
        self.high_commit_qc = qc

        # ====== attributes of PaceMaker ======
        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = None
        self.delta = 1
        self.timer = threading.Timer(None, None)
        self.ps = ps

        # ====== attributes of LeaderElection ======
        self.exclude_size = f  # f to 2f
        self.reputation_leaders = {}
        self.init_replica_ids=[]
        for i in range (2*f+1):
            self.init_replica_ids.append(i+1)

    # ====== methods of Main ======

    # def Main_current_leader():
    #     return id == self.LeaderElection_get_leader()

    def Main_can_send():
        return self.LeaderElection_get_leader(self.current_round) == self.curr_pr

    def Main_start_event_processing(message, type):
        if (type == 'local_timeout'):
            msg = self.PaceMaker_local_timeout_round()
        if (type == 'proposal_message'):
            msg = self.Main_process_proposal_msg(message)
        if (type == 'vote_message'):
            msg = self.Main_process_vote_msg(message)
        if (type == 'timeout_message'):
            msg = self.Main_process_timeout_message(message)
            if msg:
                return msg
            else:
                return None, None

    def Main_process_certificate_qc(qc):
        self.BlockTree_process_qc(qc)
        self.LeaderElection_update_leader(qc)
        self.PaceMaker_advance_round_qc(qc)

    def Main_process_proposal_msg(P):
        # self.lock_pid.acquire()

        if  P.sender!=curr_pr:
            print("remove txn for ", replica_id, curr_pr, P.sender, P.block.payload, self.mem_queue,flush=True)
            t = self.MemPool_get_transactions(P.block.payload)
            print(self.mem_queue, flush = True)
        #else:
        # self.lock_pid.release()
            #print("dont remove transactions for ", replica_id, curr_pr, P.sender)
        self.Main_process_certificate_qc(P.block.qc)
        #print("Main_process_certificate_qc")
        self.Main_process_certificate_qc(P.high_commit_qc)
        #print("Main_process_certificate_qc ")
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        #self.MemPool_get_transactions()  ## TODO: have to remove transaction from mempool
        round = self.current_round
        leader = self.LeaderElection_get_leader(round)
        #print("leader is ",leader)
        if (P.block.round != round or P.sender != leader or P.block.author != leader):
            #print("return before proposal")
            return
        self.BlockTree_execute_and_insert(P)
        vote_msg = self.Safety_make_vote(P.block, P.last_round_tc, P.high_commit_qc)
        #print("vote_msg",vote_msg)
        if (vote_msg is not None):
            print("send_vote_msg to ",self.LeaderElection_get_leader(round + 1)," from ",replica_id," in round",self.current_round)
            send( ('vote',vote_msg,logical_clock(),self.replica_id),to=self.LeaderElection_get_leader(round + 1))


    def Main_process_timeout_message(M):
        self.Main_process_certificate_qc(M.tmo_info.high_qc)
        self.Main_process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if (tc):
            self.PaceMaker_advance_round_tc(tc)
            return self.Main_process_new_round_event(tc), self.LeaderElection_get_leader(self.current_round)

    def Main_process_new_round_event(last_tc=None):
        u = self.LeaderElection_get_leader(self.current_round)
        ##print("broadcasting QC")
        if self.curr_pr == u:
            # self.lock_pid.acquire()
            b = self.BlockTree_generate_block(u, self.MemPool_get_transactions(), self.current_round)
            print("sending proposal message by leader",u,"in round",self.current_round)
            p=ProposalMsg(b, last_tc, self.high_commit_qc, u)
            # self.lock_pid.release()
            print(b.payload,"is proposed in round",self.current_round," by ",str(replica_id))
            send(('proposal', p,logical_clock()), to=replicas)


    def Main_process_vote_msg(M):
        qc = self.BlockTree_process_vote(M)
        # print("current thread in which vote msg is processed is, ", os.getpid(), "replica is ", replica_id)
        if qc:
            self.Main_process_certificate_qc(qc)
            qc.author = self.curr_pr
            self.Main_process_new_round_event(None)


    def Main_add_to_Mempool(M):
        self.MemPool_add_to_queue(M)

    # ====== methods of MemPool ======

    def MemPool_get_transactions(txns=None):
        # print("self.mem_queue is ", self.mem_queue, " txns are, ", txns)
        # await(len(self.mem_queue))
        # time.sleep(2)
        if self.test_if_mem_queue_is_full == 0:
            await(len(self.mem_queue))
            self.test_if_mem_queue_is_full = 1
        # if not self.mem_queue:
            # time.sleep(2)
            # return "nihal testing"
        # self.lock_1.acquire()
        print("after await in get_transactions")
        if txns is not None:
            if txns in self.mem_queue:
                index_of_txns = self.mem_queue.index(txns)
                # self.mem_map.pop(clock)
                self.mem_queue.pop(index_of_txns)
                if not self.mem_queue:
                    self.test_if_mem_queue_is_full = 0
        else:
            ##print("Get Transactions")
            ##print("Get Transactions after await")
            if (self.mem_queue):
                # a = self.hq.heappop()
                # a = heapq.heappop(self.hq)
                # dictionary_keys = sorted(list(self.mem_map.keys()))
                a = self.mem_queue.pop(0)
                #self.q.appendleft(a)
                # #print("Mesg",a[1])
                # return a[1]
                ##print("Mesg", a)
                # self.lock_1.release()
                return a
        #     self.lock_1.release()
        # self.lock_1.release()
        return None

    def MemPool_add_to_queue(M):
        #print("Added to queue in", M,replica_id)
        # self.hq.heappush(M)
        # M_clock, M_txns = M[1].split("###")
        # heapq.heappush(self.hq, (M[2], M[1]))
        # self.mem_map[int(M_clock)] = M_txns
        self.mem_queue.append(M[1])
        q_not_empty = True
        ##print("self.mem_queue for replica_id " + str(replica_id) + " is, ", self.mem_queue)
        # #print("self.mem_map is, ", self.mem_map)
        return

    # def MemPool_pop_txns_on_proposal(txns):
    #     if len(self.mem_map):
    #         # a = self.hq.heappop()[1]
    #         a = heapq.heappop(self.hq)
    #         # #print(a)
    #         if (a[1] != txns):
    #             # self.hq.heappush(a)
    #             heapq.heappush(self.hq, (a[2],a[1]))
    #     return

    # ====== methods of Ledger ======

    def Ledger_speculate(prev_block_id, block_id, block):

        self.pending_map[block_id] = {
            "prev_block_id": prev_block_id,
            "block": block
        }
        # pass

    def Ledger_pending_state(block_id):
        if (block_id in self.pending_map):
            if (self.pending_map[block_id]["prev_block_id"] is not None):
                return self.pending_map[block_id]["prev_block_id"]
            else:
                return None
        else:
            return None

    def Ledger_commit(block_id):

        if block_id in self.pending_map:
            file = open(self.file_name, "a+")
            #print("write to file ",self.pending_map[block_id]["block"].payload," in replica",replica_id)
            file.write(self.pending_map[block_id]["block"].payload+" time: "+str(logical_clock())+"\n")
            file.close()
            self.Ledger_add_committed_block_to_Q(block_id)
            self.pending_map.pop(block_id)
            #print("finished ledger commit")
            # TODO: look at above two lines to complete code

        # pass

    def Ledger_committed_block(block_id):
        for di in self.commited_blocks:
            if block_id in di:
                return di[block_id]
        return None

    def Ledger_add_committed_block_to_Q(block_id):
        if len(self.commited_blocks) == self.window_size:
            self.commited_blocks.popleft()
        self.commited_blocks.append(self.pending_map[block_id].copy())
        #print("finished after commiting block")

    # ====== methods of Safety ======

    def Safety_increase_highest_vote_round(round):
        self.highest_vote_round = max(round, self.highest_vote_round)

    def Safety_update_highest_qc_round(qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def Safety_consecutive(block_round, round):
        return round + 1 == block_round

    def Safety_safe_to_extend(block_round, qc_round, tc):
        if tc is not None:
            return self.Safety_consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)
        return True

    def Safety_safe_to_vote(block_round, qc_round, tc):
        if (block_round <= max(self.highest_vote_round, qc_round)):
            return False
        return self.Safety_consecutive(block_round, qc_round) or self.Safety_safe_to_extend(block_round, qc_round, tc)

    def Safety_safe_to_timeout(round, qc_round, tc):
        if (qc_round < self.highest_qc_round or round <= max(self.highest_vote_round - 1, qc_round)):
            return False
        return self.Safety_consecutive(round, qc_round) or self.Safety_consecutive(round, tc.round)

    def Safety_commit_state_id_candidate(block_round, qc, block):
        if (self.Safety_consecutive(block_round, qc.vote_info.round) and qc.vote_info.round >= 0):
            return self.Ledger_pending_state(block.id)
        else:
            return None

    def Safety_valid_signatures(high_qc, last_tc):
        i = 0
        if (high_qc.vote_info.round == -1):
            return True
        for signature in high_qc.signatures:
            if self.Safety_verify_signature(signature.id, signature.message, signature.type):
                i += 1
        if (i == 2*f+1):
            return True
        else:
            return False

    def Safety_verify_signature(id, message, type='replica'):
        if type == "replica":
            v_key = VerifyKey(self.replica_public_keys[id],
                              encoder=HexEncoder)
        elif type == 'client':
            v_key = VerifyKey(self.client_public_keys[id],
                              encoder=HexEncoder)
        try:
            v_key.verify(message)
        except BadSignatureError:
            return False
        except:
            return False

        return True

    def Safety_make_signature(block):
        return Signature(self.replica_id, self.private_key.sign(block.payload.encode('utf-8')), 'replica')

    def Safety_make_vote(block, last_tc, high_commit_qc):
        # import pdb; pdb.set_trace()
        # #print(block)
        qc_round = block.qc.vote_info.round
        # import pdb; pdb.set_trace()
        #print(self.Safety_valid_signatures(high_commit_qc, last_tc),"   ",self.Safety_safe_to_vote(block.round, qc_round,last_tc))
        if (self.Safety_valid_signatures(high_commit_qc, last_tc) and self.Safety_safe_to_vote(block.round, qc_round,
                                                                                               last_tc)):
            self.Safety_update_highest_qc_round(qc_round)
            self.Safety_increase_highest_vote_round(block.round)
            signature = self.Safety_make_signature(block)
            vote_info = VoteInfo(block.id, block.round, block.qc.vote_info.id, qc_round)
            ledger_commit_info = LedgerCommitInfo(self.Safety_commit_state_id_candidate(block.round, block.qc, block),

                                                  vote_info)
            return VoteMsg(vote_info, ledger_commit_info, high_commit_qc, sender=self.replica_id, signature=signature)
        return None

    def Safety_make_timeout(round, high_qc, last_tc):
        qc_round = high_qc.vote_info.round
        if (self.valid_signatures(high_qc, last_tc) and self.safe_to_timeout(round, qc_round, last_tc)):
            return TimeoutInfo(round, high_qc, self.curr_pr, Signature(self.replica_id, self.private_key.sign(
                str((round, high_qc.vote_info.round)).encode('utf-8')), 'replica'))
        return None

    # ====== methods of BlockTree ======

    def BlockTree_process_qc(qc):
        if qc.ledger_commit_info.commit_state_id is not None:
            self.Ledger_commit(qc.vote_info.parent_id)
            self.high_commit_qc = self.BlockTree_get_max_QC(qc, self.high_commit_qc)
        self.high_qc = self.BlockTree_get_max_QC(qc, self.high_qc)

    def BlockTree_execute_and_insert(proposal):
        self.Ledger_speculate(proposal.block.qc.vote_info.id, proposal.block.id, proposal.block)
        self.pending_block_tree.add(proposal.block)

    def BlockTree_process_vote(v):
        self.BlockTree_process_qc(v.high_commit_qc)

        vote_idx = str(v.ledger_commit_info.commit_state_id) + str(v.ledger_commit_info.vote_info_hash)
        if (self.Safety_verify_signature(v.signature.id, v.signature.message, v.signature.type)):
            self.pending_votes[vote_idx].append(v.signature)

        if self.pending_votes[vote_idx] and len(self.pending_votes[vote_idx]) == 2*f+1:
            qc = QC(vote_info=v.vote_info, ledger_commit_info=v.ledger_commit_info,
                    signatures=self.pending_votes[vote_idx].copy())
            return qc
        return None

    def BlockTree_generate_block(u, txns, current_round):
        return Block(author=u, round=current_round, payload=txns, qc=self.high_qc)

    def BlockTree_get_max_QC(qc1, qc2):
        maxQC = qc1 if (qc1.vote_info.round > qc2.vote_info.round) else qc2
        return maxQC

    # ====== methods of PaceMaker ======

    def PaceMaker_stop_timer(round):
        self.timer.cancel()
        pass

    def PaceMaker_get_round_timer(r):
        # c=logical_clock()
        return 4 * self.delta

    def PaceMaker_start_timer(new_round):
        self.current_round = new_round
        # self.timer = threading.Timer(self.get_round_timer(new_round), self.local_timeout_round)
        # self.timer.start()
        # return self.get_round_timer( self.current_round)

    def PaceMaker_local_timeout_round():

        self.PaceMaker_stop_timer(self.current_round)  ## TODO: check if this is wrong or right
        timeout_info = self.Safety_make_timeout(self.current_round, self.high_qc, self.last_round_tc)
        time_out_msg = TimeoutMsg(timeout_info, self.last_round_tc, self.high_commit_qc)
        c = logical_clock()
        send(('time_out_msg', time_out_msg, c), to=ps)

    def PaceMaker_process_remote_timeout(tmo):
        tmo_info = tmo.tmo_info
        if tmo_info:
            if (tmo_info.round < self.current_round):
                return None
            if (tmo_info.sender not in self.pending_timeouts):
                self.pending_timeouts.add(tmo_info)
            if (self.pending_timeouts.size() == f + 1):
                self.stop_timer(self.current_round)
                self.local_timeout_round()
            if (self.pending_timeouts.size() == 2 * f + 1):
                round = tmo_info.round
                tmo_high_qc_rounds = self.pending_timeouts[tmo_info.round][0].high_qc.vote_info.round
                signatures = self.pending_timeouts[tmo_info.round][0].signature
                return TC(round=round, tmo_high_qc_rounds=tmo_high_qc_rounds, tmo_signatures=signatures)
        return None

    def PaceMaker_advance_round_tc(tc):
        if (tc is None or tc.round < self.current_round):
            return False
        self.last_round_tc = tc
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc(qc):
        if qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True

    # ====== methods of LeaderElection ======

    def LeaderElection_elect_reputation_leader(qc):
        # import pdb; pdb.set_trace()
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while i < self.window_size:  # or len(last_authors) < self.exclude_size:
            current_block = self.Ledger_committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author if current_block else None
            signers = set()
            if current_qc.signatures:
                for signature in current_qc.signatures:
                    #print("sign id",signature.id)
                    signers.add(signature.id)
            else:
                #print("else current_sign",)
                signers = signers.union(init_replica_ids)
            if i < self.window_size:
                active_validators.update(signers)
            if len(last_authors) < self.exclude_size and block_author is not None:
                last_authors.add(block_author)
            if current_block:
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        print("ACTIVE_validators",active_validators," in round ",self.current_round, "in ",replica_id)
        rand_index = 0#random.randint(0, len(active_validators) - 1)
        active_validators=list(active_validators)
        print("rand_index",rand_index," in round ",self.current_round, "in ",replica_id)
        print("replica_map",replica_map)
        return replica_map[active_validators[rand_index]]   #list(active_validators)[rand_index]

    def LeaderElection_update_leader(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = self.current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            #print("befoer done")
            self.reputation_leaders[current_round + 1] = self.LeaderElection_elect_reputation_leader(qc)
            #print("done")

    def LeaderElection_get_leader(round):
        if self.reputation_leaders and round in self.reputation_leaders:
            #print(self.reputation_leaders[round])
            return self.reputation_leaders[round]
        return self.ps[int((round / 2) % len(self.ps))]
        #return self.ps[int((round) % len(self.ps))]

    # ====== methods of Validator ======

    def receive(msg=('proposal', p1, c1)):
        c2 = logical_clock()
        print("recieved proposal message " , str(p1.block.payload) , "in", replica_id,flush=True)
        #send(('proposal ack', c2), to=replicas)
        self.Main_start_event_processing(p1, 'proposal_message')

    def receive(msg=('vote', vote_info, c1,rid)):
        print("recieved vote message from  " , str(rid) , "in", self.replica_id," in round ",self.current_round)
        # check if received replica is leader using PaceMaker
        ##print("votes received before check", votes_received)
        #if received_suf_votes():
        #    return
       # output("votes_received", votes_received, " in replica", replica_id)
        votes_received = votes_received + 1
        c2 = logical_clock()
        #output("recieved vote in leader ", replica_id)
        self.Main_start_event_processing(vote_info, 'vote_message')

    def receive(msg=('request', cmd, c, p)):
        output("message received " + str(cmd) + " from " + str(p) + " at " + str(replica_id))
        M = ('request', cmd, c)
        send( ('request_ack',self.replica_id),to=p)
        #print("sent ack to client",p)
        self.Main_add_to_Mempool(M)

    def run():
        # handle first round
        output("Replica started",replica_id)
        time.sleep(5)
        if (self.Main_can_send()):
            output("sending messages to all processes from replica",replica_id)
            self.Main_process_new_round_event()
            -- l2
        # processed_votes=0

        while (1):  # keep replica always running
            #if (self.LeaderElection_get_leader(self.current_round+1)):
                -- handlemessages
                await(some( received( ('proposal',_,_))) and  (some( received( ('vote',_,_,rid) ),has =rid ==self.replica_id ) )  )

                a=0


        output("Replica ", replica_id, " is terminated")

    def received_suf_votes():
        return votes_received >= 2 * f + 1
