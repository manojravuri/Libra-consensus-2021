import os
import random
import string
import sys
import logging
import time
from libra.Logger import Logger

from .Objects import *

from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from libra.Logger import Logger

config(clock = 'Lamport')
config(handling = 'all')


class Client(process):
    def setup(client_id:int,replicas:set,rep_map:dict,f:int,number_of_requests:int,request_gap:int,client_private_key,duplicate_requests=False,faulty_client=False):

        self.client_id=client_id
        self.logfile="Client_"+str(client_id)+".log"
        Logger.log("Creating client "+str(client_id),logfile)
        self.replicas=replicas

        self.attr="Attributes of client "+str(client_id)+":\n"

        attr = attr +"number_of_requests :"+str(number_of_requests)+"\n"
        attr = attr +"request_gap :"+str(request_gap)+"\n"
        attr = attr +"faulty_client :"+str(faulty_client)

        self.number_of_requests = number_of_requests
        self.request_gap = request_gap
        self.f=f
        self.replica_timeout=5
        self.terminate=False
        self.cmds_pending={}
        self.rep_map=rep_map
        self.rep_keys=rep_map.keys()
        self.private_key=client_private_key
        self.req_root=False
        self.duplicate_requests=duplicate_requests
        self.faulty_client=faulty_client

        Logger.log(attr,logfile)

    def broadcast_request(cmd,reps):
        c=logical_clock()
        signature=sign_cmd(cmd)
        Logger.log("Client is sending :"+ cmd+" to all replicas",logfile)
        send(('request',cmd,c,client_id,signature),to=reps)
        #re-transmit
        if await(each( id in rep_keys, has=received(('request_ack', id)) ) ): pass
        elif timeout(replica_timeout):
            Logger.log("Retransmitting request because we didn't get enough acks for "+str(cmd),logfile)
            broadcast_request(cmd,reps)

    def sign_cmd(cmd):
        if not self.faulty_client:
            return Signature(self.client_id, self.private_key.sign(cmd.encode('utf-8')), 'client',None)
        else:
            Logger.log("Sending bad signature from faulty client",logfile)
            self.faulty_client=False
            faulty_private_key=SigningKey.generate()
            faulty_public_key=faulty_private_key.verify_key
            return Signature(self.client_id, faulty_private_key.sign(cmd.encode('utf-8')), 'client', None)

    def receive(msg=('committed', cmd,replica_id)):
        Logger.log('Received transaction :'+str(cmd)+' committed message from replica '+str(replica_id),logfile)
        cnt=0
        if 'dummy_txn' not in cmd :
            cmds_pending[cmd]+=1
            for cmd_ in cmds_pending:
                if cmds_pending[cmd_] >= 2*f+1:
                    cnt = cnt + 1
                    #return
        Logger.log('Transactions committed count :'+str(cnt)+','+str(number_of_requests),logfile)
        if (cnt == (number_of_requests-2)) and  not req_root :
            Logger.log('Request root to send dummy txns to replicas',logfile)
            send(('send dummy txns',logical_clock()),to=parent())
            req_root=True
        elif cnt == number_of_requests:
            self.terminate=True



    def run():
        for i in range(number_of_requests):
            time.sleep(request_gap)
            cmd=str(client_id)+"----->"+str(i)
            cmds_pending[cmd]=0
            broadcast_request(cmd,replicas)

            if(self.duplicate_requests):
                broadcast_request(cmd, replicas)
        await(self.terminate)
        Logger.log("Terminating client "+str(client_id),logfile)
        send(('client_done',client_id,logical_clock()),to=parent())
