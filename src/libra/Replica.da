import os
import random
import time
from collections import deque
from collections import defaultdict
from .Objects import *
import threading
import random
import copy
import os
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from nacl.exceptions import BadSignatureError
from libra.Logger import Logger

import time

config(clock='Lamport')
config(handling='all')

TIMEOUT = 1


class Replica(process):
    def setup(replica_id: int, curr_pr, ps: list,rep_map:dict,cl_map:dict, f: int, replica_public_keys=None,client_public_keys=None,replica_private_key=None,message_delay=False,message_loss=False):
        # ====== attributes of Replica ======

        self.replica_id = replica_id
        self.logfile="Replica_"+str(replica_id)+".log"
        Logger.log("Creating Replica "+str(replica_id),logfile)
        self.f = f
        self.replicas = ps
        self.replica_map=rep_map
        self.inv_map = {v: k for k, v in replica_map.items()}
        self.client_map=cl_map
        self.request_map={}
        self.terminate=False
        self.message_loss=message_loss
        self.message_delay=message_delay

        self.attr="Attributes of Replica "+str(replica_id)+":\n"

        # ====== attributes of Main ======

        self.window_size = 1
        attr = attr +"window_size :"+str(window_size)+"\n"
        self.curr_pr = curr_pr

        # ====== attributes of MemPool ======

        self.processed_transactions = []
        self.mem_queue =  []

        # ====== attributes of Ledger ======
        cur_path = os.getcwd()
        self.file_name = os.path.abspath(cur_path + "/../ledgers/Ledger_" + str(self.replica_id) + ".txt")
        self.pending_map = {}
        self.commited_blocks = {}  # committed block with window size
        self.ledger_state = ""
        self.commit_state_id= hash("")

        # ====== attributes of Safety ======
        self.highest_vote_round = -1
        self.highest_qc_round = -1

        self.private_key = replica_private_key
        self.replica_public_keys = replica_public_keys
        self.client_public_keys = client_public_keys

        # ====== attributes of BlockTree ======

        self.pending_block_tree = set()
        self.pending_votes = defaultdict(list)
        vote_info = VoteInfo(-1, -1, -2, -2)
        ledger_commit_info = LedgerCommitInfo(None, vote_info)
        qc = QC(vote_info, ledger_commit_info)
        genesis_block = Block(0, -1, "", qc)
        self.high_qc = qc
        self.high_commit_qc = qc

        # ====== attributes of PaceMaker ======

        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = {}
        self.delta = 2
        attr = attr +"delta :"+str(delta)+"\n"
        self.timer = threading.Timer(None, None)
        self.ps = ps
        self.timer_map={}

        # ====== attributes of LeaderElection ======
        self.exclude_size = f  # f to 2f
        attr = attr +"exclude_size :" +str(exclude_size)+"\n"
        attr = attr +"commit_state_id :"+str(commit_state_id)

        self.reputation_leaders = {}
        self.init_replica_ids=[]
        for i in range (2*f+1):
            self.init_replica_ids.append(i+1)

        Logger.log(attr,logfile)
    # ====== methods of Main ======

    #Will check if the current process is the leader for the current round
    def Main_can_send():
        return self.LeaderElection_get_leader(self.current_round) == self.curr_pr

    #All messages will go through this function. Based on the type, the appropriate functions are called.
    def Main_start_event_processing(message, type):
        Logger.log("Started event processing for message " + str(message) + " of type " + str(type) ,logfile)
        if (type == 'local_timeout'):
            self.PaceMaker_local_timeout_round()
        if (type == 'proposal_message'):
            self.Main_process_proposal_msg(message)
        if (type == 'vote_message'):
            self.Main_process_vote_msg(message)
        if (type == 'timeout_message'):
            self.Main_process_timeout_message(message)

    #The below function will process the qc certificate received in the message. based on that it will update the leader, round and add appropriate blocks
    #Procedure process certificate qc(qc)
    # Block-Tree.process qc(qc)
    # LeaderElection.update leaders(qc)
    # Pacemaker.advance round(qc.vote info.round)
    def Main_process_certificate_qc(qc):
        Logger.log("Started process certificate qc" ,logfile)
        self.BlockTree_process_qc(qc)
        self.LeaderElection_update_leader(qc)
        self.PaceMaker_advance_round_qc(qc)

    # This method is used to process the message received by the followers, the following is the pseudocode from the paper
    # Procedure process proposal msg(P)
    #     process certificate qc(P.block.qc)
    #     process certificate qc(P.high commit qc)
    #     Pacemaker.advance round tc(P.last round tc)
    #     round ← Pacemaker.current round
    #     leader ← LeaderElection.get leader(current round)
    #     if P.block.round 6= round ∨ P.sender 6= leader ∨ P.block.author 6= leader then
    #     return
    #     Block-Tree.execute and insert(P) // Adds a new speculative state to the Ledger
    #     vote msg ← Safety.make vote(P.block, P.last round tc)
    #     if vote msg 6= ⊥ then
    #     send vote msg to LeaderElection.get leader(current round + 1)
    def Main_process_proposal_msg(P):
        Logger.log("Started event processing", logfile)
        if  P.sender!=curr_pr:
            t = self.MemPool_get_transactions(P.block.payload)
        self.Main_process_certificate_qc(P.block.qc)
        self.Main_process_certificate_qc(P.high_commit_qc)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        round = self.current_round
        leader = self.LeaderElection_get_leader(round)
        if (P.block.round != round or P.sender != leader or P.block.author != leader):
            return
        self.BlockTree_execute_and_insert(P)
        vote_msg = self.Safety_make_vote(P.block, P.last_round_tc, P.high_commit_qc)
        if (vote_msg is not None):
            Logger.log("Sending vote message to : "+str(inv_map[leader]),logfile)
            leader=self.LeaderElection_get_leader(round+1)
            if(self.message_loss):
                Logger.log("Message loss in replica",logfile)
                #send( ('vote',vote_msg,logical_clock(),replica_id),to=leader)
            elif(self.message_delay):
                Logger.log("Message delay in replica",logfile)
                time.sleep(2)
                send(('vote', vote_msg, logical_clock(), replica_id), to=leader)
            else:
                send(('vote', vote_msg, logical_clock(), replica_id), to=leader)

    # The below code will be used to process timeout messages.
    # Procedure process timeout msg(M)
        # process certificate qc(M.tmo info.high qc)
        # process certificate qc(M.high commit qc)
        # Pacemaker.advance round tc(M.last round tc)
        # tc ← Pacemaker.process remote timeout(M)
        # if tc 6= ⊥ then
        # Pacemaker.advance round(tc)
        # process new round event(tc)
    def Main_process_timeout_message(M):
        Logger.log("Started processing timeout message." ,logfile)
        self.Main_process_certificate_qc(M.tmo_info.high_qc)
        self.Main_process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if (tc):
            Logger.log("Generating a timeout certificate",logfile)
            self.PaceMaker_advance_round_tc(tc)
            self.Main_process_new_round_event(tc)

    # Whenever a leader is assigned, it tries to send a proposalmsg to its followers using the below function.
    # Procedure process new round event(last tc)
        # if u = LeaderElection.get leader(Pacemaker.current round) then
            # // Leader code: generate proposal.
            # b ← Block-Tree.generate block( MemPool.get transactions(),
            # Pacemaker.current round )
            # broadcast ProposalMsghb, last tc, Block-Tree.high_commit_qc
    def Main_process_new_round_event(last_tc=None):
        Logger.log("Started processing new round event ",logfile)
        u = self.LeaderElection_get_leader(self.current_round)
        if self.curr_pr == u:
            b = self.BlockTree_generate_block(u, self.MemPool_get_transactions(), self.current_round)
            p=ProposalMsg(b, last_tc, self.high_commit_qc, u)
            Logger.log("Sending Proposal message to all replicas containing block ->"
        +"Block Author :"+str(inv_map[p.block.author])+" Transactions :"+str(p.block.payload),logfile)
            Logger.log("Sending new round event ",logfile)
            send(('proposal', p,logical_clock(),replica_id), to=replicas)

    # Process VoteMsg object recieved by the Leader. The below code is in correspondence with the commented pesudocode.
    # Procedure process vote msg(M)
        # qc ← Block-Tree.process vote(M)
        # if qc 6= ⊥ then
        # process certificate qc(qc)
        # process new round event(⊥)
    def Main_process_vote_msg(M):
        Logger.log("Started processing vote message ",logfile)
        qc = self.BlockTree_process_vote(M)
        if qc:
            self.Main_process_certificate_qc(qc)
            qc.author = self.curr_pr
            self.Main_process_new_round_event(None)

    # This function is called by the handler which recieves message from the client to add the requests to the appropriate mempool.
    def Main_add_to_Mempool(M):
        self.MemPool_add_to_queue(M)

    # ====== methods of MemPool ======

    # This is used to get the latest un-procesed transaction when it is called from the leader. And it is also used to remove processed transactions when it is called by the followers.
    # / We call this function in two cases.
	# // 1. When a new leader has to get the latest transaction to be processed.
	# // 2. When a replica has to remove the current processing transaction from its own cache of mem_queue

    def MemPool_get_transactions(txns=None):
        if txns:
            self.processed_transactions.append(txns) # it means a leader is processing txns

        if not self.mem_queue:
            await(len(self.mem_queue)) # wait till some transaction is put in mem_queue
        if txns:
            # // this statement will be acted upon in followers, so we have to remove the txns from the pending transactions in the current replica (mem_queue)
            # Remove txns from the mem_queue of current replica
            if txns in self.mem_queue:
                index_of_txns = self.mem_queue.index(txns)
                self.mem_queue.pop(index_of_txns)
        else:
            # //this call will be done in leader
            # Get the earliest transaction present in mem_queue and send it to Main process to send a ProposalMsg
            if (self.mem_queue):
                a = self.mem_queue.pop(0)
                if a in self.processed_transactions:
                    Logger.log('Duplicate txn'+str(a)+" will not be processed")
                    return self.MemPool_get_transactions()
                self.processed_transactions.append(a)
                return a
        return None

    # This function will be called from the client to add the request in the replica’s mempool
    # Add M to the mem_queue of the current replica
    def MemPool_add_to_queue(M):
        self.mem_queue.append(M[1])
        return

    # ====== methods of Ledger ======

    # apply txns speculatively
    # // Make a mapping in speculate to store the block data with block_id as key
    def Ledger_speculate(prev_block_id, block_id, block):
        Logger.log("Adding block with " + str(block_id) + " in ledger pending_map",logfile)
        self.pending_map[block_id] = {
            "prev_block_id": prev_block_id,
            "block": block
        }

    # find the pending state for the given block id or ⊥ if not present
    # Check if block_id is present in the pending_map and return the corresponding block data
    def Ledger_pending_state(block_id):
        Logger.log("Fetching pending state for block_id " + str(block_id),logfile)
        if block_id in self.pending_map and self.pending_map[block_id]["prev_block_id"]:
            return hash(str( self.commit_state_id) +str(self.pending_map[block_id]["prev_block_id"]) )
        else:
            return None


    # commit the pending prefix of the given block id and prune other branches
    # Check if block_id is present in pending map
    # What it does is mentioned below:
    # If block_id is in cache:
	# 	Pop and commit that block to the ledger and add the blocks in committed_blocks map
	# Else If block_id is not in cache:
		# Do nothing
    def Ledger_commit(block_id):

        if block_id in self.pending_map:

            block=self.pending_map[block_id]["block"]
            txn=block.payload
            if('dummy_txn' not in txn):
                file = open(self.file_name, "a+")
                self.commit_state_id=hash(str(self.commit_state_id)+str(txn))
                file.write("block-author:"+str(inv_map[block.author])+" , block-round: "+str(block.round)+" , payload: "+txn+"\n")
                file.close()
                Logger.log("Committed txn : "+str(txn)+" to ledger",logfile)
                send(('committed',txn,replica_id),to=request_map[txn])
            self.commited_blocks[block_id]=self.pending_map[block_id].copy()
            Logger.log("Updated commited-blocks cache",logfile)
            self.pending_map.pop(block_id)
            Logger.log("Pruned pending state tree.",logfile)

    # Check in committed_blocks if the block_id is there
    # returns a committed block given its id
    # If the block_is in cache, it will return the relevant information.
    # else: it will return nothing
    def Ledger_committed_block(block_id):
        if block_id in self.commited_blocks :
            return self.commited_blocks[block_id]["block"]
        return None


    # ====== methods of Safety ======
    # commit not to vote in rounds lower than round
    def __Safety_increase_highest_vote_round(round):
        self.highest_vote_round = max(round, self.highest_vote_round)

    # it updates highest_qc_round
    def __Safety_update_highest_qc_round(qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    # check if the block round and the current round are consecutive
    def __Safety_consecutive(block_round, round):
        return round + 1 == block_round

    # it is used to make safety check on whether or not a replica is allowed to do a particular operation
    def __Safety_safe_to_extend(block_round, qc_round, tc):
        if tc is not None:
            return self.__Safety_consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)
        return True

    # it is used to check if the current block is safe to vote
    def __Safety_safe_to_vote(block_round, qc_round, tc):
        if (block_round <= max(self.highest_vote_round, qc_round)):
            # must vote in monotonically increasing rounds
            # must extend a smaller round
            return False
        return self.__Safety_consecutive(block_round, qc_round) or self.__Safety_safe_to_extend(block_round, qc_round, tc)

    # check if current parameters is safe to timeout
    def __Safety_safe_to_timeout(round, qc_round, tc):
        if (qc_round < self.highest_qc_round or round <= max(self.highest_vote_round - 1, qc_round)):
            return False
        return self.__Safety_consecutive(round, qc_round) or self.__Safety_consecutive(round, tc.round)

    # find the committed id in case a qc is formed in the vote round
    def __Safety_commit_state_id_candidate(block_round, qc, block):
        if (self.__Safety_consecutive(block_round, qc.vote_info.round) and qc.vote_info.round >= 0):
            return self.Ledger_pending_state(block.id)
        else:
            return None

    # This is a custom function to check if the given qc or tc have valid signatures
    def Safety_valid_signatures(high_qc, last_tc):
        i = 0
        if (high_qc.vote_info.round == -1):
            return True
        for signature in high_qc.signatures:
            if self.Safety_verify_signature(signature.id, signature.message, signature.type):
                i += 1
        if (i == 2*f+1):
            return True
        else:
            return False

    # This is a helper function to Safety_valid_signatures and it will use VerifyKey to check if a sign is valid
    def Safety_verify_signature(id, message, type='replica'):
        if type == "replica":
            v_key = VerifyKey(self.replica_public_keys[id],
                              encoder=HexEncoder)
        elif type == 'client':
            v_key = VerifyKey(self.client_public_keys[id],
                              encoder=HexEncoder)
        try:
            v_key.verify(message)
        except BadSignatureError:
            Logger.log("Bad signature from"+type+" "+str(id),logfile)
            return False
        except:
            return False
        return True

    # creates a signature object from the block data
    def Safety_make_signature(block):
        return Signature(self.replica_id, self.private_key.sign(block.payload.encode('utf-8')), 'replica', self.curr_pr)

    # checks if the current parameters are good to vote on and returns a VoteMsg if it is right, or else returns None
    def Safety_make_vote(block, last_tc, high_commit_qc):
        Logger.log("Started make vote",logfile)
        qc_round = block.qc.vote_info.round
        if (self.Safety_valid_signatures(high_commit_qc, last_tc) and self.__Safety_safe_to_vote(block.round, qc_round,
                                                                                               last_tc)):

            Logger.log("Verified Signatures for proposal." ,logfile)
            self.__Safety_update_highest_qc_round(qc_round) # Protect qc round
            self.__Safety_increase_highest_vote_round(block.round) # Don’t vote again in this (or lower) round
            # VoteInfo carries the potential QC info with ids and rounds of the parent QC
            signature = self.Safety_make_signature(block)
            Logger.log("Generated signature to make vote ",logfile)
            vote_info = VoteInfo(block.id, block.round, block.qc.vote_info.id, qc_round)
            ledger_commit_info = LedgerCommitInfo(self.__Safety_commit_state_id_candidate(block.round, block.qc, block),

                                                  vote_info)
            Logger.log("Finished make vote ",logfile)
            return VoteMsg(vote_info, ledger_commit_info, high_commit_qc, sender=self.replica_id, signature=signature)
        Logger.log("Finished make vote ",logfile)
        return None

    # It is called in local_timeout and it will be used to return a TimeoutInfo Object which is again passed on to prepare a TimeoutMsg.
    def Safety_make_timeout(round, high_qc, last_tc):
        Logger.log("Calling make_timeout",logfile)
        qc_round = high_qc.vote_info.round
        if (self.Safety_valid_signatures(high_qc, last_tc) and self.__Safety_safe_to_timeout(round, qc_round, last_tc)):
            Logger.log("Generating signature for replica, " + str(self.replica_id),logfile)
            return TimeoutInfo(round, high_qc, self.curr_pr, Signature(self.replica_id, self.private_key.sign(
                str((round, high_qc.vote_info.round)).encode('utf-8')), 'replica', self.curr_pr))
        return None

    # ====== methods of BlockTree ======

    # Used to process QC
    def BlockTree_process_qc(qc):
        if qc.ledger_commit_info.commit_state_id is not None: # checking if the given qc has a parent commited in the pending_block_tree
            self.Ledger_commit(qc.vote_info.parent_id) # pruning is also being done in this function, when something is being commited; its child is promoted.
            self.high_commit_qc = self.BlockTree_get_max_QC(qc, self.high_commit_qc) # We used a custom comparator of QC's to update high_commit_qc
        self.high_qc = self.BlockTree_get_max_QC(qc, self.high_qc) # We used a custom comparator of QC's to update high_qc

    #Procedure execute and insert(b)
        # Ledger.speculate(b.qc.block id, b.id, b.payload)
        # pending block tree.add(b)
    # This is used to speculate a proposal, which means the block in that proposal is added in the ledger cache
    # we arent using pending_block_tree attribute in our code. Instead of it, we are using pending_map which is present in Ledger.
    def BlockTree_execute_and_insert(proposal):
        Logger.log("Executing and Inserting",logfile)
        self.Ledger_speculate(proposal.block.qc.vote_info.id, proposal.block.id, proposal.block)
        self.pending_block_tree.add(proposal.block)

#     Function process vote(v)
        # process qc(v.high commit qc)
        # vote idx ← hash(v.ledger commit info)
        # pending votes[vote idx] ← pending votes[vote idx] ∪ v.signature
        # if |pending votes[vote idx]| = 2f + 1 then
        # qc ←QC h
        # vote info ← v.vote info,
        # state id ← v.state id,
        # votes ← pending votes[vote idx] i
        # return qc
        # return ⊥
    # This function is used to process the VoteMsg object received by the leader.
    def BlockTree_process_vote(v):
        Logger.log("Processing Vote",logfile)
        self.BlockTree_process_qc(v.high_commit_qc)

        vote_idx = str(v.ledger_commit_info.commit_state_id) + str(v.ledger_commit_info.vote_info_hash)
        if (self.Safety_verify_signature(v.signature.id, v.signature.message, v.signature.type)):
            self.pending_votes[vote_idx].append(v.signature)
            Logger.log("Signature verified to process vote. ",logfile)

        if self.pending_votes[vote_idx] and len(self.pending_votes[vote_idx]) == 2*f+1:
            qc = QC(vote_info=v.vote_info, ledger_commit_info=v.ledger_commit_info,
                    signatures=self.pending_votes[vote_idx].copy())
            return qc
        return None

    #This is a set function used to generate blocks given the parameters
    def BlockTree_generate_block(u, txns, current_round):
        Logger.log("Generating Block",logfile)
        return Block(author=u, round=current_round, payload=txns, qc=self.high_qc)

    # This is a custom comparator within the QC objects, which returns 'a' in (a, b) if the round of a > round of b
    def BlockTree_get_max_QC(qc1, qc2):
        maxQC = qc1 if (qc1.vote_info.round > qc2.vote_info.round) else qc2
        return maxQC

    # ====== methods of PaceMaker ======

    # We utilised threading to implement timers. When the below function is called, the timer is stopped.
    def PaceMaker_stop_timer(round):
        Logger.log("Stopping round in PaceMaker",logfile)
        timer_map[round]=False
        self.timer.cancel()
        pass

    # This is used to get the allowed time delay for each round.
    def PaceMaker_get_round_timer(r):
        return 4 * self.delta

    # This function is used to start the timer for the new round. Starting the timer means to start a thread for PaceMaker_get_round_timer(round) time. If that much time is passed, then the thread will call local_timeout in the parent process.
    def PaceMaker_start_timer(new_round):
        Logger.log("Started round in PaceMaker",logfile)
        self.current_round = new_round
        if new_round not in timer_map:
            timer_map[new_round]=True
        self.timer = threading.Timer(self.PaceMaker_get_round_timer(new_round), self.PaceMaker_local_timeout_round)
        self.timer.start()

    #This function is called to generate a local timeout.
    def PaceMaker_local_timeout_round():
        if(not self.terminate):
            Logger.log("Creating a local timeout at "+str(self.replica_id),logfile)
            self.PaceMaker_stop_timer(self.current_round) # it is used to stop the timer for the current round
            timeout_info = self.Safety_make_timeout(self.current_round, self.high_qc, self.last_round_tc) # Create a TimeOutInfo object
            time_out_msg = TimeoutMsg(timeout_info, self.last_round_tc, self.high_commit_qc) # TimeOutMsg to send it to its neighbors
            c = logical_clock()
            send(('time_out_msg', time_out_msg, c), to=ps)

    # When a replica gets a TimeOutMsg from its neighbor, then this function will be called.
    def PaceMaker_process_remote_timeout(tmo):
        Logger.log("Processing remote time out",logfile)
        tmo_info=tmo.tmo_info
        if tmo_info:
            if (tmo_info.round < self.current_round): # it means that the round for which timeout happened is less than the current round. So, nothing should take place.
                return None
            # the following if clauses will be used to check if a TC is formed or if f + 1timeouts from different replicas are formed.
            if(tmo_info.round not in self.pending_timeouts):
                self.pending_timeouts[tmo_info.round]={}
                self.pending_timeouts[tmo_info.round]["tmos"]=[]
                self.pending_timeouts[tmo_info.round]["senders"]=[]
            if ( tmo_info.sender not in self.pending_timeouts[tmo_info.round]["senders"]):
                self.pending_timeouts[tmo_info.round]["tmos"].append(tmo_info)
                self.pending_timeouts[tmo_info.round]["senders"].append(tmo_info.sender)
            if (len(self.pending_timeouts[tmo_info.round]["senders"]) ==  f+1):
                self.PaceMaker_stop_timer(self.current_round)
                self.PaceMaker_local_timeout_round()
            if (len(self.pending_timeouts[tmo_info.round]["senders"]) ==  2*f+1):
                round = tmo_info.round
                tmo_high_qc_rounds = []
                signatures=[]
                for tmo_info_in_round in self.pending_timeouts[tmo_info.round]["tmos"]:
                    tmo_high_qc_rounds.append(tmo_info_in_round.round)
                    signatures.append(tmo_info_in_round.signature)
                return TC(round = round, tmo_high_qc_rounds=tmo_high_qc_rounds, tmo_signatures=signatures)
        return None

    # This function uses the TC information to advance the round. It is used in syncing up.
    def PaceMaker_advance_round_tc(tc):
        Logger.log("Advancing round based on tc",logfile)
        if (tc is None or tc.round < self.current_round):
            return False
        self.last_round_tc = tc
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(tc.round + 1)
        return True

    # This function uses the QC information to advance the round. It is used in syncing up.
    def PaceMaker_advance_round_qc(qc):
        Logger.log("Advancing round based on qc",logfile)
        if qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True

    # ====== methods of LeaderElection ======


    def LeaderElection_elect_reputation_leader(qc):
        active_validators = set() # validators that signed the last window size committed blocks
        last_authors = set() # ordered set of authors of last exclude size committed blocks
        current_qc = qc
        i = 0
        while i < self.window_size:
            current_block = self.Ledger_committed_block(current_qc.vote_info.parent_id) # get block of parent block of qc
            block_author = current_block.author if current_block else None
            signers = set()
            if current_qc.signatures:
                for signature in current_qc.signatures:
                    signers.add(signature.replica_process) # adds signatures of current qc to signers
            else:
                signers = signers.union(replicas)
            if i < self.window_size:
                active_validators.update(signers) # the active validators are updates using signers of current_qc
            if len(last_authors) < self.exclude_size and block_author is not None:
                last_authors.add(block_author)
            if current_block:
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        rand_index = 0
        active_validators=list(active_validators)
        return active_validators[rand_index] # return the replica present at rand_index in the active_validators list

    # This is called from process_qc in Main. It is used to update the leader of the next round using reputation leader function.
    def LeaderElection_update_leader(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = self.current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            self.reputation_leaders[current_round + 1] = self.LeaderElection_elect_reputation_leader(qc)

    # returns the leader of the round
    def LeaderElection_get_leader(round):
       return self.ps[int((round) % len(self.ps))]

    # ====== methods of Validator ======

    # This handler is called when a message with 'proposal' tag is sent to the replica process.
    # the message is sent from the leader of the round, and it will be processed in the followers
    def receive(msg=('proposal', p1, c1,sid)):
        Logger.log("Received proposal message from "+str(sid)+ " containing block ->"
        +"Block Author :"+str(inv_map[p1.block.author])+" Transactions :"+str(p1.block.payload),logfile)
        self.Main_start_event_processing(p1, 'proposal_message')

    # This handler is called when a message with 'vote' tag is sent to the replica process.
    # the message is sent from the followers of the round, and it will be processed in the leader
    def receive(msg=('vote', vote_info, c1,rid)):
        Logger.log("Received vote message from "+str(rid),logfile)
        self.Main_start_event_processing(vote_info, 'vote_message')

    # This handler is called when a message with 'request' tag is sent to the replica process with 4 arguments (from Client)
    # the message is sent from the clients and it will be processed in all the replicas.
    def receive(msg=('request', cmd, c, p,signature)):
        Logger.log("Received Client Request from "+str(p),logfile)
        if(self.Safety_verify_signature(signature.id, signature.message, signature.type)): # if the client signature is not valid, then we will retransmit the message
            Logger.log("verified client signature for cmd " + str(cmd),logfile)
            M = ('request', cmd, c)
            if cmd in request_map:
                Logger.log("Received duplicate "+str(cmd)+" which has been dropped",logfile) # here deduplication happens
                send( ('request_ack',self.replica_id),to=client_map[p])
            else:
                request_map[cmd]=client_map[p]
                send( ('request_ack',self.replica_id),to=client_map[p])
                self.Main_add_to_Mempool(M) # adds the request M in the local MemPool if it is not a duplicate

    # This handler is called when a message with 'request' tag is sent to the replica process with only 3 arguments (from Root)
    # This function is used to ensure that all the relevant transactions are vote on and committed
    # the message is sent from the root, at the end of the whole process
    def receive(msg=('request', cmd, c, p)):
        Logger.log("Received dummy txn Request from Root",logfile)
        print(p,parent())
        if(p==parent()):
            M = ('request', cmd, c)
            Logger.log("Sending ack back to Root",logfile)
            send(('request_ack',self.replica_id),to=parent())
            self.Main_add_to_Mempool(M)

    # This handler is called when a message with 'time_out_msg' tag is sent to the replica process.
    # It means some other replica has had a local_timeout and this handler will recieve the message.
    # the message is sent from the timed out replicas and it will be processed in other replicas
    def receive(msg=('time_out_msg', timeout_msg,c)):
        Logger.log("Received local timeout",logfile)
        self.Main_start_event_processing(timeout_msg,'timeout_message')

    # In our termination process, once the client terminates, it sends a request back to the Root.
    # Then the Root will send a termination signal to the replicas.
    # The below is a handler to handle a termination signal.
    def receive(msg=('done',sender)):
        Logger.log("Received Terminate signal from Root",logfile)
        if sender==parent():
            send(('replica_done',replica_id),to=parent())
            Logger.log("Terminate replica :"+str(replica_id),logfile)
            self.PaceMaker_stop_timer(self.current_round)
            self.terminate=True


    def run():
        # handle first round
        Logger.log("Replica started "+str(replica_id),logfile)
        if (self.Main_can_send()):
            Logger.log("sending messages to all processes from replica "+str(replica_id),logfile)
            self.Main_process_new_round_event()


        while (not self.terminate):  # keep replica always running
            if (self.LeaderElection_get_leader(self.current_round+1)):
                -- handlemessages



        Logger.log("Replica "+str(replica_id)+ " is terminated",logfile)
