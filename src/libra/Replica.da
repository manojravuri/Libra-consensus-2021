import os
import random
import string
import sys
import logging
import time
from collections import deque
from collections import defaultdict
from .Objects import *
import pickle
import threading

config(clock = 'Lamport')
config(handling = 'all')

TIMEOUT=1


def setup(replica_id:int,nodes:dict,ps:set,f:int,number_of_requests:int,all_replica_public_keys,all_client_public_keys:list,replica_private_key:list):
        output("creating replica ", replica_id)
        self.main = Main(replica_id,nodes,all_replica_public_keys,all_client_public_keys,replica_private_key)
        self.nodes = nodes
        self.f = f
        self.ps=ps
        self.proposals=set()
        self.all_replica_public_keys=all_replica_public_keys
        self.all_client_public_keys=all_client_public_keys
        self.replica_private_key=replica_private_key
        self.number_of_requests = number_of_requests

class Replica(process):
    def setup(replica_id:int,curr_pr,ps:list,f:int,number_of_requests:int,all_replica_public_keys:list,all_client_public_keys:list,replica_private_key):
    # ====== attributes of Replica ======
        output("creating replica ", replica_id)
        self.f = f
        self.all_nodes=list(ps)
        self.ps=ps-{curr_pr}
        self.proposals=set()
        self.number_of_requests = number_of_requests
        self.processing_req=False
    # ====== attributes of Main ======
        self.replica_id = replica_id
        self.window_size = 1
        self.curr_pr = curr_pr
        self.all_replica_public_keys=all_replica_public_keys
        self.all_client_public_keys=all_client_public_keys
        self.replica_private_key=replica_private_key




    # ====== attributes of MemPool ======
        self.q = deque()

    # ====== attributes of Ledger ======
        cur_path = os.getcwd()
        self.file_name = os.path.abspath(cur_path + "/../data/Ledger_" + str(self.replica_id) + ".txt")
        self.pending_map = {}
        self.committed_blocks = deque()  # committed block with window size
        self.ledger_state = ""

    # ====== attributes of Safety ======
        #self.private_key = private_key
        self.highest_vote_round = -1
        self.highest_qc_round = -1

    # ====== attributes of BlockTree ======
        self.pending_block_tree = set()
        self.pending_votes = defaultdict(list)
        vote_info = VoteInfo("block_id", -1, "parent_block_id", -2,hash("pending state of block_id"))
        ledger_commit_info = LedgerCommitInfo(None,vote_info)
        signatures=[]
        for i in range (2*f+1):
            signatures.append(i)
        self.high_commit_qc = QC(vote_info, ledger_commit_info,signatures,"Rohith","Rohith_sign")
        vote_info = VoteInfo("block_id", 1, "parent_block_id", 0,hash("pending state of block_id"))
        ledger_commit_info = LedgerCommitInfo(None,vote_info)
        self.high_qc = QC(vote_info, ledger_commit_info,signatures,"Rohith","Rohith_sign_hQC")

    # ====== attributes of PaceMaker ======
        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = None
        self.delta = 1
        self.timer = 0

    # ====== attributes of LeaderElection ======
        self.exclude_size = None  # f to 2f
        self.reputation_leaders = {}

    # ====== methods of Main ======
    def Main_current_leader():
        return id == LeaderElection_get_leader()

    def Main_can_send():
        return LeaderElection_get_leader(self.current_round) == self.replica_id

    def Main_start_event_processing(M, type):
        #print("message in sep")
        message = M
        if (type == 'local_timeout'):
            self.PaceMaker_local_timeout_round()
        if (type == 'proposal_message'):
            msg,sender = self.Main_process_proposal_msg(message)
            print("msg",msg)
            print("sender",sender)
            return msg,all_nodes[sender]
        if (type == 'vote_message'):
            msg = self.Main_process_vote_msg(message)
            print("got msg in sep , ", msg)
            if msg:
                return msg
            else:
                return None, None
        if (type == 'timeout_mesaage'):
            self.Main_process_timeout_message(message)

    def Main_process_certificate_qc(qc):
        self.BlockTree_process_qc(qc)
        print("process qc done")
        LeaderElection_update_leader(qc)
        print("leader election done")
        self.PaceMaker_advance_round_qc(qc)
        print("advance round done")

    def Main_process_proposal_msg(P):
        print("processing certificate qc")
        self.Main_process_certificate_qc(P.block.qc)
        print("processing high commit qc")
        self.Main_process_certificate_qc(P.high_commit_qc)
        print("Advancing current round",self.current_round)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        print("advanced round",self.current_round)
        round = self.current_round
        leader = LeaderElection_get_leader(round)
        print("WORKING")
        if (P.block.round != round or P.sender != leader or P.block.author != leader):
            return
        print("generating block")
        block_P = self.BlockTree_generate_block(self.replica_id, self.MemPool_get_transactions(), round, P.high_commit_qc)
        print("generated block")
        self.BlockTree_execute_and_insert(block_P)
        print("executed and inserted")
        vote_msg = self.Safety_make_vote(block_P, P.last_round_tc, P.high_commit_qc)
        print("make vote done",vote_msg)
        if vote_msg:
            print("new leader is, ", LeaderElection_get_leader(round + 1))
            return vote_msg, (LeaderElection_get_leader(round + 1))
            # send vote_msg to LeaderElection.get_leader(current_round+1)

    def Main_process_timeout_message(M):
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if (tc):
            self.PaceMaker_advance_round_qc(tc)
            self.process_new_round_event(tc)

    def Main_process_new_round_event(last_tc):
        # u = self.replica_id

        u = LeaderElection_get_leader(self.current_round)

        # if u == LeaderElection_get_leader(self.current_round):
        b = self.BlockTree_generate_block(u, self.MemPool_get_transactions(), self.current_round,
                                           high_qc=self.high_commit_qc)
        p = ProposalMsg(b, last_tc, self.high_commit_qc,replica_id)
        return p

    def Main_process_vote_msg(M):
        print("Mis ", M)
        qc = self.block_tree.process_vote(M)
        print("qc done")
        if (qc):
            self.process_certificate_qc(qc)
            print("here is it")
            return self.process_new_round_event(qc.last_tc), LeaderElection_get_leader(
                self.current_round)
            # return None, LeaderElection_get_leader(self.current_round)

    def Main_workload_exists():
        if (self.MemPool_get_transactions()):
            return True
        else:
            return False

    def Main_add_to_Mempool( M):
        self.MemPool_add_to_queue(M)


    # ====== methods of MemPool ======


    def MemPool_get_transactions():
        print("Get Transactions")
        if len(self.q):
            a = self.q.popleft()
            self.q.appendleft(a)
            return a
        return None

    def MemPool_increment_txn_start_num():
        print("Popped from queue")
        self.q.popleft()
        return

    def MemPool_add_to_queue( M):
        print("Added to queue in", M,replica_id)
        self.q.append(M)
        q_not_empty=True
        return

    def MemPool_is_q_empty():
        return not len(self.q)


    # ====== methods of Ledger ======


    def Ledger_speculate( prev_block_id, block_id, block):
        self.pending_map[block_id] = {
            "prev_block_id": prev_block_id,
            "block": block,
        }
        pass

    def Ledger_pending_state(block_id):
        return self.pending_map[block_id]["block"].payload

    def Ledger_commit(block_id):
        # update start txn after commit
        file = open(self.file_name, "w+")
        file.write(self.pending_map[block_id]["block"].payload)
        file.close()
        print("persisted to ledger remember to use flsuh and fsync later")
        self.add_committed_block_to_Q(block_id)
        self.ledger_state = hash(self.ledger_state +"||"+ self.pending_map[block_id]["block"].payload)
        self.pending_map = {}

        # pass

    def Ledger_committed_block( block_id):
        for di in self.committed_blocks:
            if block_id in di:
                return di[block_id]
        return None

    def Ledger_add_committed_block_to_Q( block_id):
        if len(self.committed_blocks) == self.window_size:
            self.committed_blocks.popleft()
        self.committed_blocks.append(self.pending_map[block_id])


    # ====== methods of Safety ======


    def Safety_increase_highest_vote_round(round):
        self.highest_vote_round = max(round, self.highest_vote_round)

    def Safety_update_highest_qc_round( qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def Safety_consecutive( block_round, round):
        return round + 1 == block_round

    def Safety_safe_to_extend( block_round, qc_round, tc):
        return Safety_consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)

    def Safety_safe_to_vote( block_round, qc_round, tc):
        if (block_round <= max(self.highest_vote_round, qc_round)):
            return False
        return Safety_consecutive(block_round, qc_round) and Safety_safe_to_extend( block_round, qc_round, tc)

    def Safety_safe_to_timeout( round, qc_round, tc):
        if (qc_round < self.highest_qc_round or round <= max(self.highest_vote_round - 1, qc_round)):
            return False
        return Safety_consecutive( round, qc_round) or Safety_consecutive( round, tc.round)

    def Safety_commit_state_id_candidate( block_round, qc):
        if (Safety_consecutive(block_round, qc.vote_info.round)):
            return Ledger_pending_state(qc.id)
        else:
            return None

    def Safety_valid_signatures( high_qc, last_tc):
        return True

    def Safety_make_vote( b, last_tc, high_commit_qc):
        qc_round = b.qc.vote_info.round
        print(b.round, qc_round, last_tc.round)
        print(Safety_safe_to_vote(b.round, qc_round, last_tc))
        if self.Safety_valid_signatures(b, last_tc) and Safety_safe_to_vote(b.round, qc_round, last_tc):
            self.Safety_update_highest_qc_round(qc_round)
            self.Safety_increase_highest_vote_round(b.round)
            vote_info = VoteInfo(b.id, b.round, b.qc.vote_info.id, b.qc.vote_info.round,Ledger_pending_state(b.id))
            ledger_commit_info = LedgerCommitInfo(self.commit_state_id_candidate(b.round, b.qc), hash(vote_info))
            return VoteMsg(vote_info, ledger_commit_info, high_commit_qc, replica_id, str(replica_id)+"sign")
        return None

    def Safety_make_timeout( round, high_qc, last_tc):
        qc_round = high_qc.vote_info.round
        if (self.Safety_valid_signatures(high_qc, last_tc) and self.safe_to_timeout(round, qc_round, last_tc)):
            return TimeoutInfo(round, high_qc)
        return None

    # ====== methods of BlockTree ======


    def BlockTree_process_qc(qc):
        print("ledger commit id in qc",qc.ledger_commit_info.commit_state_id)
        if qc.ledger_commit_info.commit_state_id:
            self.Ledger_commit( qc.vote_info.parent_id)
            # prune branches
            # self.pending_block_tree.prune(qc.vote_info_parent_id)
            self.high_commit_qc = self.BlockTree_get_max_QC(qc, self.high_commit_qc)
        self.high_qc = self.BlockTree_get_max_QC(qc, self.high_qc)
        # print("process qc done")

    def BlockTree_execute_and_insert(b):
        # print(b)
        self.Ledger_speculate(b.qc.vote_info.id, b.id, b)
        self.pending_block_tree.add(b)

    def BlockTree_process_vote(v):
        print("in process_vote ", v)
        self.BlockTree_process_qc(v.high_commit_qc)

        vote_idx = hash(v.ledger_commit_info)
        print("vote_idx is , ", vote_idx)

        self.pending_votes[vote_idx].append(v.signature)
        print("self.pending_votes[vote_idx] is , ", self.pending_votes[vote_idx])

        if self.pending_votes[vote_idx] and len(self.pending_votes[vote_idx]) == (2 * self.f + 1):
            qc = QC(vote_info=v.vote_info, votes=self.pending_votes[vote_idx])
            print("QuorumC", QC)
            return qc
        return None

    def BlockTree_generate_block( u, txns, current_round, high_qc):
        return Block(author=u, round=current_round, payload=txns, qc=high_qc)

    def BlockTree_get_max_QC(qc1, qc2):
        print("qc1",qc1.vote_info.round)
        print("qc2", qc2.vote_info.round)
        maxQC = qc1 if (qc1.vote_info.round > qc2.vote_info.round) else qc2
        return maxQC

    # ====== methods of PaceMaker ======


    def PaceMaker_stop_timer( round):
        self.timer.cancel()
        pass

    def PaceMaker_get_round_timer( r):
        # c=logical_clock()
        return 4 * self.delta

    def PaceMaker_start_timer( new_round):
        # self.stop_timer(self.current_round)
        self.current_round = new_round
        self.timer = threading.Timer(self.get_round_timer(1), self.local_timeout_round())
        self.timer.start()
        # return self.get_round_timer( self.current_round)

    def PaceMaker_local_timeout_round():
        # save_consensus_state()
        print("local timeout")
        self.stop_timer(self.current_round)
        timeout_info = self.Safety_make_timeout(self.current_round, self.block_tree.high_qc, self.last_round_tc)
        print("broadcast Timeout to Replicas")
        # broadcast TimeoutMsg(timeout_info,self.last_round_tc,self.block_tree.high_commit_qc)

    def PaceMaker_process_remote_timeout( tmo):
        tmo_info = tmo.tmo_info
        if (tmo_info.round < self.current_round):
            return None
        if (tmo_info.sender not in self.pending_timeouts):
            self.pending_timeouts.add(tmo_info)
        if (self.pending_timeouts.size() == f + 1):
            self.stop_timer(self.current_round)
            self.local_timeout_round()
        if (self.pending_timeouts.size() == 2 * f + 1):
            round = tmo_info.round
            tmo_high_qc_rounds = self.pending_timeouts[tmo_info.round][0].high_qc.round
            signatures = self.pending_timeouts[tmo_info.round][0].signature
        return None

    def PaceMaker_advance_round_tc(tc):
        if tc is None or tc.round < self.current_round:
            return False
        self.last_round_tc = tc
        self.start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc( qc):
        if qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.start_timer(qc.vote_info.round + 1)
        return True


    # ====== methods of LeaderElection ======


    def LeaderElection_elect_reputation_leader(qc):
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while i < self.window_size or len(last_authors) < self.exclude_size:
            current_block = self.Ledger_committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author if current_block else None
            if i < self.window_size:
                active_validators=set.union(active_validators,set(current_qc.signatures))
            if len(last_authors) < self.exclude_size and block_author:
                last_authors.add(block_author)
            if current_block:
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        print("active_validators is ", active_validators)
        return active_validators[random.randint(0, len(active_validators) - 1)]

    def LeaderElection_update_leader( qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = self.current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            self.reputation_leaders[current_round + 1] = self.LeaderElection_elect_reputation_leader(qc)

    def LeaderElection_get_leader(round):
        if self.reputation_leaders and round in self.reputation_leaders:
            return self.reputation_leaders[round]
        return int((round / 2) % len(all_nodes))


    # ====== methods of Validator ======


    def receive(msg=('proposal',p1,c1)):
        c2=logical_clock()
        output("recieved proposal message in",replica_id)
        send(('proposal ack',c2), to=ps)
        p, leader = self.Main_start_event_processing(p1,'proposal_message')
        print("sending votes to next leader")
        send(('vote',p,logical_clock()),to=leader)

    def receive(msg=('vote',vote_info,c1)):
        c2=logical_clock()
        output("recieved vote in leader ",replica_id)
        vote_info,leader=self.Main_start_event_processing(vote_info,'vote_message')
        if leader and vote_info:
          output("got vote_info, leader")
          send(('proposal',vote_info,logical_clock()),to=leader)

    def receive(msg=('request',cmd,c,p)):
        output("message received "+str(cmd)+" from "+str(p)+" at "+str(replica_id))
        M=('request',cmd,c)
        self.Main_add_to_Mempool(M)
        processing_req=True

    def receive(msg = ('time_out_msg', time_out_msg, c2)):
        output("timeout message received" + str(time_out_msg) + " to " + str(replica_id))
        proposal, leader = self.Main_start_event_processing(time_out_msg,'timeout_message')
        if leader and proposal:
          output("got proposal, leader")
          


    def run():
        time.sleep(5)
        if(self.Main_can_send()):
            p=self.Main_process_new_round_event(TC(-10))
            output("sending messages to all processes from replica",replica_id)
            c=logical_clock()
            send(('proposal',p,c),to=ps)
            -- l2
           # processed_votes=0
        while(1):
            -- handlemessages
           # await(len(setof(a,received(('proposal ack',c3), from_=a)))>2*f+1)
            #time.sleep(1)
        #await(len(setof(a,received(('done',c3), from_=a)))>2*f+1)
        output("Replica ", replica_id," is terminated")
