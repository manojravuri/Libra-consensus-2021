from libra.Replica import Replica
from libra.Client import Client

import os
import sys, time

from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from libra.Logger import Logger

config(clock='Lamport')

# Root is the orchestrator for the whole process and it will setup the clients and replicas based on the config file.
def main():

    Logger.cleanup() # to initialise a new set of log and ledger files.
    logfile='Root.log'
    Logger.log("Main process started",logfile) # starts a log file
    if len(sys.argv) > 1:
        config_file = sys.argv[1]
    else:
        config_file = 'config2.txt'

    """ reading config from file """
    config = {}
    with open(os.path.join(os.path.abspath(''), 'libra/config', config_file), 'r') as input: # gets a config file and loads the input into config map.
        for line in input:
            if line[0] != '#':
                (key, sep, val) = line.partition('=')
                if len(sep) != 0:
                    val = val.strip()
                    config[key.strip()] = int(val) if str.isdecimal(val) else val

    # print(config)

    # os._exit(-1)
    # number_of_procs = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    # number_of_reqs = int(sys.argv[2]) if len(sys.argv) > 1 else 4
    number_of_procs = config['number_of_procs']
    # number_of_reqs = config['number_of_reqs']

     ####Keys
    replica_public_keys = []
    replica_private_keys = []

    # generating keys for replicas
    for i in range(number_of_procs):
        signing_key = SigningKey.generate()
        verify_key = signing_key.verify_key
        verify_key_b64 = verify_key.encode(encoder=HexEncoder)
        replica_public_keys.append(verify_key_b64)
        replica_private_keys.append(signing_key)

    ##clients
    number_of_clients = config['number_of_clients']

    #cps = new(Client, num=number_of_clients)

    client_private_keys = []
    client_public_keys = []

    # generating keys for clients
    for i in range(number_of_clients):
        signing_key = SigningKey.generate()
        verify_key = signing_key.verify_key
        verify_key_b64 = verify_key.encode(encoder=HexEncoder)
        client_public_keys.append(verify_key_b64)
        client_private_keys.append(signing_key)


    f=int((number_of_procs-1)/3)
    replicas = new(Replica, num= number_of_procs)

    rep_map={}
    cl_map={}
    replicas=list(replicas)
    i=0
    for p in replicas:
        rep_map[i]=p
        i=i+1

    rep_keys=rep_map.keys()

    ##clients

    client_reqs=config['client_reqs']
    request_gap=config['request_gap']
    cps=new(Client, num= number_of_clients)

    i=0
    for cp in cps:
        cl_map[i]=cp
        i=i+1

    i=0
    for p in replicas:
        setup(p, (i,p,replicas,rep_map,cl_map,f,replica_public_keys,client_public_keys,replica_private_keys[i]))
        i=i+1

    start(replicas)


    i=0
    for cp in cps:
        setup(cp, (i,replicas,rep_map,f,client_reqs,request_gap,client_private_keys[i]))
        i=i+1
    start(cps)

    await(len(setof(a,received(  ('send dummy txns',_), from_=a))) == number_of_clients)
    Logger.log("All clients requested to send replicas empty block",logfile)

    # this loop is to send dummy transactions to ensure that all the required transactions are committed.
    for i in range(2):
        c=logical_clock()
        cmd=str(number_of_clients) + "--->" + 'dummy_txn'+str(i)
        Logger.log("Root is sending :"+ cmd+" to all replicas",logfile)
        send(('request',cmd,c,parent()),to=replicas)
        #re-transmit
        if await(each( id in rep_keys, has=received(('request_ack', id)) ) ): pass
        elif timeout(5): broadcast_request(cmd,replicas,rep_keys)

    await(len(setof(a,received(  ('client_done',_,_), from_=a))) == number_of_clients)
   # output("Clients are done executions")

    send( ('done',self),to= replicas)

    #output("Sending done to replicas")
    #send(('replica_done',replica_id,logical_clock()),to=parent())

    await(len(setof(a,received( ('replica_done',_),from_=a) ) ) ==  number_of_procs )
   # output("Replicas are done executions")
    Logger.log("Main function is terminating",logfile)
    os._exit(-1)
