from libra.Replica import Replica
from libra.ReplicaFI import ReplicaFI
from libra.Client import Client
from libra.ClientFI import ClientFI

import os
import sys, time

from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from libra.Logger import Logger

config(clock='Lamport')


def main():

    Logger.cleanup()
    logfile='Root.log'
    Logger.log("Main process started",logfile)
    if len(sys.argv) > 1:
        config_file = sys.argv[1]
    else:
        config_file = 'configNoFault.txt'
    Logger.log("Generating workload based on config file "+str(config_file),logfile)
    """ reading config from file """
    config = {}
    with open(os.path.join(os.path.abspath(''), 'libra/config', config_file), 'r') as input:
        for line in input:
            if line[0] != '#':
                (key, sep, val) = line.partition('=')
                if len(sep) != 0:
                    val = val.strip()
                    config[key.strip()] = int(val) if str.isdecimal(val) else val

    # print(config)
    Logger.log("Generated workload based on config file "+str(config_file),logfile)
    # os._exit(-1)
    # number_of_procs = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    # number_of_reqs = int(sys.argv[2]) if len(sys.argv) > 1 else 4
    number_of_procs = config['number_of_procs']
    # number_of_reqs = config['number_of_reqs']

     ####Keys
    replica_public_keys = []
    replica_private_keys = []

    for i in range(number_of_procs):
        signing_key = SigningKey.generate()
        verify_key = signing_key.verify_key
        verify_key_b64 = verify_key.encode(encoder=HexEncoder)
        replica_public_keys.append(verify_key_b64)
        replica_private_keys.append(signing_key)
    Logger.log("Generated signature keys for replicas",logfile)
    ##clients
    number_of_clients = config['number_of_clients']

    #cps = new(Client, num=number_of_clients)

    client_private_keys = []
    client_public_keys = []

    for i in range(number_of_clients):
        signing_key = SigningKey.generate()
        verify_key = signing_key.verify_key
        verify_key_b64 = verify_key.encode(encoder=HexEncoder)
        client_public_keys.append(verify_key_b64)
        client_private_keys.append(signing_key)

    Logger.log("Generated signature keys for clients",logfile)
    f=int((number_of_procs-1)/3)
    replicas = new(Replica, num= number_of_procs)


    #print("config['time_out_commit']",config['time_out_commit'])
    #print("config['time_out_TC']",config['time_out_TC'])


    if(config['time_out_commit']=="True"):
        #logging.log("Running replicas with f timeout replicas",logfile)
        replicas = new(Replica, num=number_of_procs - f)

        faulty_replicas = new(ReplicaFI, num=f)

        replicas.update(faulty_replicas)
    elif(config['time_out_TC']=="True"):
        #logging.log("Running replicas with f+1 timeout replicas",logfile)
        replicas = new(Replica, num=number_of_procs - f-1)

        faulty_replicas = new(ReplicaFI, num=f+1)

        replicas.update(faulty_replicas)
    else:
        #logging.log("Running replicas without faulty replicas",logfile)
        replicas = new(Replica, num=number_of_procs)

    rep_map={}
    cl_map={}
    replicas=list(replicas)
    i=0
    for p in replicas:
        rep_map[i]=p
        i=i+1

    rep_keys=rep_map.keys()

    ##clients

    client_reqs=config['client_reqs']
    request_gap=config['request_gap']
    if('faulty_client' in config and config['faulty_client']=='True'):
        faulty_clients=int(number_of_clients/2)
        cps = new(Client, num=faulty_clients)
        cp1 = new(ClientFI, num=number_of_clients-faulty_clients)
        cps.update(cp1)
    else:
        cps = new(Client, num=number_of_clients)

    i=0
    for cp in cps:
        cl_map[i]=cp
        i=i+1

    i=0
    for p in replicas:
        setup(p, (i,p,replicas,rep_map,cl_map,f,replica_public_keys,client_public_keys,replica_private_keys[i]))
        i=i+1

    start(replicas)


    i=0
    for cp in cps:
        setup(cp, (i,replicas,rep_map,f,client_reqs,request_gap,client_private_keys[i]))
        i=i+1
    start(cps)

    await(len(setof(a,received(  ('send dummy txns',_), from_=a))) == number_of_clients)
    Logger.log("All clients requested to send replicas empty block",logfile)


    for i in range(2):
        c=logical_clock()
        cmd=str(number_of_clients) + "--->" + 'dummy_txn'+str(i)
        Logger.log("Root is sending :"+ cmd+" to all replicas",logfile)
        send(('request',cmd,c,parent()),to=replicas)
        #re-transmit
        if await(each( id in rep_keys, has=received(('request_ack', id)) ) ): pass
        elif timeout(5): broadcast_request(cmd,replicas,rep_keys)

    await(len(setof(a,received(  ('client_done',_,_), from_=a))) == number_of_clients)
   # output("Clients are done executions")

    send( ('done',self),to= replicas)

    #output("Sending done to replicas")
    #send(('replica_done',replica_id,logical_clock()),to=parent())

    await(len(setof(a,received( ('replica_done',_),from_=a) ) ) ==  number_of_procs )
   # output("Replicas are done executions")
    Logger.log("Main function is terminating",logfile)
    os._exit(-1)
