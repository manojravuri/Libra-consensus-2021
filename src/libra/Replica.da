import os
import random
import time
from collections import deque
from collections import defaultdict
from .Objects import *
import threading
import random
import copy
import os
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from libra.Logger import Logger

import time

config(clock='Lamport')
config(handling='all')

TIMEOUT = 1


class Replica(process):
    def setup(replica_id: int, curr_pr, ps: list,rep_map:dict,cl_map:dict, f: int, replica_public_keys=None,client_public_keys=None,replica_private_key=None):
        # ====== attributes of Replica ======

        self.replica_id = replica_id
        self.logfile="Replica_"+str(replica_id)+".log"
        Logger.log("creating replica "+str(replica_id),logfile)
        self.f = f
        self.replicas = ps
        self.proposals = set()
        self.processing_req = False
        self.votes_received = 0
        self.replica_map=rep_map
        self.inv_map = {v: k for k, v in replica_map.items()}
        self.client_map=cl_map
        self.request_map={}
        self.terminate=False
        random.seed(6)

        # ====== attributes of Main ======


        self.window_size = 1
        self.replica_id = replica_id
        self.win_sz = 1
        self.curr_pr = curr_pr

        # ====== attributes of MemPool ======
        
        self.processed_transactions = []
        self.mem_queue =  []
        self.test_if_mem_queue_is_full = 0

        # ====== attributes of Ledger ======
        cur_path = os.getcwd()
        self.file_name = os.path.abspath(cur_path + "/../data/Ledger_" + str(self.replica_id) + ".txt")
        self.pending_map = {}
        self.commited_blocks = {}  # committed block with window size
        self.ledger_state = ""
        self.commit_state_id= hash("")

        # ====== attributes of Safety ======
        self.highest_vote_round = -1
        self.highest_qc_round = -1

        self.private_key = replica_private_key
        self.replica_public_keys = replica_public_keys
        self.client_public_keys = client_public_keys

        # ====== attributes of BlockTree ======

        self.pending_block_tree = set()
        self.pending_votes = defaultdict(list)
        vote_info = VoteInfo(-1, -1, -2, -2)
        ledger_commit_info = LedgerCommitInfo(None, vote_info)
        qc = QC(vote_info, ledger_commit_info)
        genesis_block = Block(0, -1, "", qc)
        self.high_qc = qc
        self.high_commit_qc = qc

        # ====== attributes of PaceMaker ======

        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = {}
        self.delta = 2
        self.timer = threading.Timer(None, None)
        self.ps = ps
        self.timer_map={}

        # ====== attributes of LeaderElection ======
        self.exclude_size = f  # f to 2f
        self.reputation_leaders = {}
        self.init_replica_ids=[]
        for i in range (2*f+1):
            self.init_replica_ids.append(i+1)

    # ====== methods of Main ======

    def Main_can_send():
        return self.LeaderElection_get_leader(self.current_round) == self.curr_pr

    def Main_start_event_processing(message, type):
        if (type == 'local_timeout'):
            self.PaceMaker_local_timeout_round()
        if (type == 'proposal_message'):
            self.Main_process_proposal_msg(message)
        if (type == 'vote_message'):
            self.Main_process_vote_msg(message)
        if (type == 'timeout_message'):
            self.Main_process_timeout_message(message)

    def Main_process_certificate_qc(qc):
        self.BlockTree_process_qc(qc)
        self.LeaderElection_update_leader(qc)
        self.PaceMaker_advance_round_qc(qc)

    def Main_process_proposal_msg(P):
        if  P.sender!=curr_pr:
            t = self.MemPool_get_transactions(P.block.payload)
        self.Main_process_certificate_qc(P.block.qc)
        self.Main_process_certificate_qc(P.high_commit_qc)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        round = self.current_round
        leader = self.LeaderElection_get_leader(round)
        if (P.block.round != round or P.sender != leader or P.block.author != leader):
            return
        self.BlockTree_execute_and_insert(P)
        vote_msg = self.Safety_make_vote(P.block, P.last_round_tc, P.high_commit_qc)
        if (vote_msg is not None):
                Logger.log("Sending vote message to : "+str(inv_map[leader]),logfile)
                leader=self.LeaderElection_get_leader(round+1)
                send( ('vote',vote_msg,logical_clock(),replica_id),to=leader)


    def Main_process_timeout_message(M):
        self.Main_process_certificate_qc(M.tmo_info.high_qc)
        self.Main_process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if (tc):
            self.PaceMaker_advance_round_tc(tc)
            self.Main_process_new_round_event(tc)

    def Main_process_new_round_event(last_tc=None):
        u = self.LeaderElection_get_leader(self.current_round)
        if self.curr_pr == u:
            b = self.BlockTree_generate_block(u, self.MemPool_get_transactions(), self.current_round)
            p=ProposalMsg(b, last_tc, self.high_commit_qc, u)
            Logger.log("Sending Proposal message to all replicas containing block ->"
        +"Block Author :"+str(inv_map[p.block.author])+" Transactions :"+str(p.block.payload),logfile)
            send(('proposal', p,logical_clock(),replica_id), to=replicas)


    def Main_process_vote_msg(M):
        qc = self.BlockTree_process_vote(M)
        if qc:
            self.Main_process_certificate_qc(qc)
            qc.author = self.curr_pr
            self.Main_process_new_round_event(None)


    def Main_add_to_Mempool(M):
        self.MemPool_add_to_queue(M)

    # ====== methods of MemPool ======

    def MemPool_get_transactions(txns=None):
        if txns is not None:
            self.processed_transactions.append(txns)

        if not self.mem_queue:
            await(len(self.mem_queue))
        if txns is not None:
            if txns in self.mem_queue:
                index_of_txns = self.mem_queue.index(txns)
                self.mem_queue.pop(index_of_txns)
            return None
        else:
            if (self.mem_queue):
                a = self.mem_queue.pop(0)
                if a in self.processed_transactions:
                    Logger.log('Duplicate txn'+str(a)+" will not be processed")
                    return self.MemPool_get_transactions()
                self.processed_transactions.append(a)
                return a
            else:
                Logger.log("Memqueue is empty",logfile)
        return None

    def MemPool_add_to_queue(M):
        self.mem_queue.append(M[1])
        return

    # ====== methods of Ledger ======

    def Ledger_speculate(prev_block_id, block_id, block):

        self.pending_map[block_id] = {
            "prev_block_id": prev_block_id,
            "block": block
        }

    def Ledger_pending_state(block_id):
        if (block_id in self.pending_map):
            if (self.pending_map[block_id]["prev_block_id"] is not None):
                return hash(str( self.commit_state_id) +str(self.pending_map[block_id]["prev_block_id"]) )
            else:
                return None
        else:
            return None

    def Ledger_commit(block_id):

        if block_id in self.pending_map:

            block=self.pending_map[block_id]["block"]
            txn=block.payload
            if('dummy_txn' not in txn):
                file = open(self.file_name, "a+")
                self.commit_state_id=hash(str(self.commit_state_id)+str(txn))
                file.write("block-author:"+str(inv_map[block.author])+" , block-round: "+str(block.round)+" , payload: "+txn+"\n")
                file.close()
                Logger.log("Committed txn : "+str(txn)+" to ledger",logfile)
                send(('committed',txn,replica_id),to=request_map[txn])
            self.Ledger_add_committed_block_to_Q(block_id)
            self.pending_map.pop(block_id)

    def Ledger_committed_block(block_id):
        a=None
        if block_id in self.commited_blocks :
            a= self.commited_blocks[block_id]["block"]
        return a

    def Ledger_add_committed_block_to_Q(block_id):
        # if len(self.commited_blocks) == self.exclude_size:
        #     self.commited_blocks.popleft()
        self.commited_blocks[block_id]=self.pending_map[block_id].copy()

    # ====== methods of Safety ======

    def Safety_increase_highest_vote_round(round):
        self.highest_vote_round = max(round, self.highest_vote_round)

    def Safety_update_highest_qc_round(qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def Safety_consecutive(block_round, round):
        return round + 1 == block_round

    def Safety_safe_to_extend(block_round, qc_round, tc):
        if tc is not None:
            return self.Safety_consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)
        return True

    def Safety_safe_to_vote(block_round, qc_round, tc):
        if (block_round <= max(self.highest_vote_round, qc_round)):
            return False
        return self.Safety_consecutive(block_round, qc_round) or self.Safety_safe_to_extend(block_round, qc_round, tc)

    def Safety_safe_to_timeout(round, qc_round, tc):
        if (qc_round < self.highest_qc_round or round <= max(self.highest_vote_round - 1, qc_round)):
            return False
        return self.Safety_consecutive(round, qc_round) or self.Safety_consecutive(round, tc.round)

    def Safety_commit_state_id_candidate(block_round, qc, block):
        if (self.Safety_consecutive(block_round, qc.vote_info.round) and qc.vote_info.round >= 0):
            return self.Ledger_pending_state(block.id)
        else:
            return None

    def Safety_valid_signatures(high_qc, last_tc):
        i = 0
        if (high_qc.vote_info.round == -1):
            return True
        for signature in high_qc.signatures:
            if self.Safety_verify_signature(signature.id, signature.message, signature.type):
                i += 1
        if (i == 2*f+1):
            return True
        else:
            return False

    def Safety_verify_signature(id, message, type='replica'):
        if type == "replica":
            v_key = VerifyKey(self.replica_public_keys[id],
                              encoder=HexEncoder)
        elif type == 'client':
            v_key = VerifyKey(self.client_public_keys[id],
                              encoder=HexEncoder)
        try:
            v_key.verify(message)
        except BadSignatureError:
            return False
        except:
            return False
        return True

    def Safety_make_signature(block):
        return Signature(self.replica_id, self.private_key.sign(block.payload.encode('utf-8')), 'replica', self.curr_pr)

    def Safety_make_vote(block, last_tc, high_commit_qc):
        qc_round = block.qc.vote_info.round
        if (self.Safety_valid_signatures(high_commit_qc, last_tc) and self.Safety_safe_to_vote(block.round, qc_round,
                                                                                               last_tc)):
            self.Safety_update_highest_qc_round(qc_round)
            self.Safety_increase_highest_vote_round(block.round)
            signature = self.Safety_make_signature(block)
            vote_info = VoteInfo(block.id, block.round, block.qc.vote_info.id, qc_round)
            ledger_commit_info = LedgerCommitInfo(self.Safety_commit_state_id_candidate(block.round, block.qc, block),

                                                  vote_info)
            return VoteMsg(vote_info, ledger_commit_info, high_commit_qc, sender=self.replica_id, signature=signature)
        return None

    def Safety_make_timeout(round, high_qc, last_tc):
        qc_round = high_qc.vote_info.round
        if (self.Safety_valid_signatures(high_qc, last_tc) and self.Safety_safe_to_timeout(round, qc_round, last_tc)):
            return TimeoutInfo(round, high_qc, self.curr_pr, Signature(self.replica_id, self.private_key.sign(
                str((round, high_qc.vote_info.round)).encode('utf-8')), 'replica', self.curr_pr))
        return None

    # ====== methods of BlockTree ======

    def BlockTree_process_qc(qc):
        if qc.ledger_commit_info.commit_state_id is not None:
            self.Ledger_commit(qc.vote_info.parent_id)
            self.high_commit_qc = self.BlockTree_get_max_QC(qc, self.high_commit_qc)
        self.high_qc = self.BlockTree_get_max_QC(qc, self.high_qc)

    def BlockTree_execute_and_insert(proposal):
        self.Ledger_speculate(proposal.block.qc.vote_info.id, proposal.block.id, proposal.block)
        self.pending_block_tree.add(proposal.block)

    def BlockTree_process_vote(v):
        self.BlockTree_process_qc(v.high_commit_qc)

        vote_idx = str(v.ledger_commit_info.commit_state_id) + str(v.ledger_commit_info.vote_info_hash)
        if (self.Safety_verify_signature(v.signature.id, v.signature.message, v.signature.type)):
            self.pending_votes[vote_idx].append(v.signature)

        if self.pending_votes[vote_idx] and len(self.pending_votes[vote_idx]) == 2*f+1:
            qc = QC(vote_info=v.vote_info, ledger_commit_info=v.ledger_commit_info,
                    signatures=self.pending_votes[vote_idx].copy())
            return qc
        return None

    def BlockTree_generate_block(u, txns, current_round):
        return Block(author=u, round=current_round, payload=txns, qc=self.high_qc)

    def BlockTree_get_max_QC(qc1, qc2):
        maxQC = qc1 if (qc1.vote_info.round > qc2.vote_info.round) else qc2
        return maxQC

    # ====== methods of PaceMaker ======

    def PaceMaker_stop_timer(round):
        timer_map[round]=False
        self.timer.cancel()
        pass

    def PaceMaker_get_round_timer(r):
        return 4 * self.delta

    def PaceMaker_start_timer(new_round):
        self.current_round = new_round
        if new_round not in timer_map:
            timer_map[new_round]=True
        self.timer = threading.Timer(self.PaceMaker_get_round_timer(new_round), self.PaceMaker_local_timeout_round)
        self.timer.start()

    def PaceMaker_local_timeout_round():
        if(not self.terminate):
            Logger.log("Creating a local timeout at "+str(self.replica_id),logfile)
            self.PaceMaker_stop_timer(self.current_round)  
            timeout_info = self.Safety_make_timeout(self.current_round, self.high_qc, self.last_round_tc)
            time_out_msg = TimeoutMsg(timeout_info, self.last_round_tc, self.high_commit_qc)
            c = logical_clock()
            send(('time_out_msg', time_out_msg, c), to=ps)

    def PaceMaker_process_remote_timeout(tmo):
        tmo_info=tmo.tmo_info
        if tmo_info:
            if (tmo_info.round < self.current_round):
                return None
            if(tmo_info.round not in self.pending_timeouts):
                self.pending_timeouts[tmo_info.round]={}
                self.pending_timeouts[tmo_info.round]["tmos"]=[]
                self.pending_timeouts[tmo_info.round]["senders"]=[]
            if ( tmo_info.sender not in self.pending_timeouts[tmo_info.round]["senders"]):
                self.pending_timeouts[tmo_info.round]["tmos"].append(tmo_info)
                self.pending_timeouts[tmo_info.round]["senders"].append(tmo_info.sender)
            if (len(self.pending_timeouts[tmo_info.round]["senders"]) ==  f+1):
                self.PaceMaker_stop_timer(self.current_round)
                self.PaceMaker_local_timeout_round()
            if (len(self.pending_timeouts[tmo_info.round]["senders"]) ==  2*f+1):
                round = tmo_info.round
                tmo_high_qc_rounds = []
                signatures=[]
                for tmo_info_in_round in self.pending_timeouts[tmo_info.round]["tmos"]:
                    tmo_high_qc_rounds.append(tmo_info_in_round.round)
                    signatures.append(tmo_info_in_round.signature)
                return TC(round = round, tmo_high_qc_rounds=tmo_high_qc_rounds, tmo_signatures=signatures)
        return None

    def PaceMaker_advance_round_tc(tc):
        if (tc is None or tc.round < self.current_round):
            return False
        self.last_round_tc = tc
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc(qc):
        if qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_stop_timer(self.current_round)
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True

    # ====== methods of LeaderElection ======

    def LeaderElection_elect_reputation_leader(qc):
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while i < self.window_size:
            current_block = self.Ledger_committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author if current_block else None
            signers = set()
            if current_qc.signatures:
                for signature in current_qc.signatures:
                    signers.add(signature.replica_process)
            else:
                signers = signers.union(replicas)
            if i < self.window_size:
                active_validators.update(signers)
            if len(last_authors) < self.exclude_size and block_author is not None:
                last_authors.add(block_author)
            if current_block:
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        rand_index = 0
        active_validators=list(active_validators)
        return active_validators[rand_index]   

    def LeaderElection_update_leader(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = self.current_round
        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            self.reputation_leaders[current_round + 1] = self.LeaderElection_elect_reputation_leader(qc)

    def LeaderElection_get_leader(round):
       return self.ps[int((round) % len(self.ps))]

    # ====== methods of Validator ======

    def receive(msg=('proposal', p1, c1,sid)):
        Logger.log("Received proposal message from "+str(sid)+ " containing block ->"
        +"Block Author :"+str(inv_map[p1.block.author])+" Transactions :"+str(p1.block.payload),logfile)
        self.Main_start_event_processing(p1, 'proposal_message')

    def receive(msg=('vote', vote_info, c1,rid)):
        Logger.log("Received vote message from "+str(rid),logfile)
        self.Main_start_event_processing(vote_info, 'vote_message')


    def receive(msg=('request', cmd, c, p,signature)):
        Logger.log("Received Client Request from "+str(p),logfile)
        if(self.Safety_verify_signature(signature.id, signature.message, signature.type)):
            M = ('request', cmd, c)
            if cmd in request_map:
                Logger.log("Received duplicate "+str(cmd)+" which has been dropped",logfile)
                send( ('request_ack',self.replica_id),to=client_map[p])
            else:        
                request_map[cmd]=client_map[p]
                send( ('request_ack',self.replica_id),to=client_map[p])
                self.Main_add_to_Mempool(M)

    def receive(msg=('request', cmd, c, p)):
        Logger.log("Received dummy txn Request from Root",logfile)
        print(p,parent())
        if(p==parent()):
            M = ('request', cmd, c)
            Logger.log("Sending ack back to Root",logfile)
            send(('request_ack',self.replica_id),to=parent())
            self.Main_add_to_Mempool(M)


    def receive(msg=('time_out_msg', timeout_msg,c)):
        Logger.log("Received local timeout",logfile)
        self.Main_start_event_processing(timeout_msg,'timeout_message')


    def receive(msg=('done',sender)):
        Logger.log("Received Terminate signal from Root",logfile)
        if sender==parent():
            send(('replica_done',replica_id),to=parent())
            Logger.log("Terminate replica :"+str(replica_id),logfile)
            self.PaceMaker_stop_timer(self.current_round)
            self.terminate=True


    def run():
        # handle first round
        Logger.log("Replica started "+str(replica_id),logfile)
        time.sleep(5)
        if (self.Main_can_send()):
            Logger.log("sending messages to all processes from replica "+str(replica_id),logfile)
            self.Main_process_new_round_event()
            -- l2
        

        while (not self.terminate):  # keep replica always running
            if (self.LeaderElection_get_leader(self.current_round+1)):
                -- handlemessages
                #await(some( received( ('proposal',_,_))) and  (some( received( ('vote',_,_,rid) ),has =rid ==self.replica_id ) )  )



        Logger.log("Replica "+str(replica_id)+ " is terminated",logfile)
