import os
import random
import string
import sys
import logging
import time
from .Main import Main
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
config(clock = 'Lamport')
config(handling = 'all')

TIMEOUT=1

class Replica(process):
    def setup(replica_id:int,nodes:dict,ps:set,f:int,number_of_requests:int,all_replica_public_keys,all_client_public_keys:list,replica_private_key:list):
        output("creating replica ", replica_id)
        self.main = Main(replica_id,nodes[replica_id], nodes,all_replica_public_keys,all_client_public_keys,replica_private_key)
        self.nodes = nodes
        self.f = f
        self.ps=ps
        self.proposals=set()
        self.all_replica_public_keys=all_replica_public_keys
        self.all_client_public_keys=all_client_public_keys
        self.replica_private_key=replica_private_key
        self.number_of_requests = number_of_requests

    def receive(msg=('proposal',p1,c1)):
        c2=logical_clock()
        output("recieved message in",replica_id)
        send(('proposal ack',c2), to=ps)
        #print("p1 is ", p1)
        p, id = self.main.start_event_processing(p1,'proposal_message')
        #print("p and leader is, ", p, leader)
        leader = nodes[id]
        if p and leader:
            #leader = nodes[leader]
            output("Sending vote message to replicas",id)
            send(('vote',p,logical_clock()),to=leader)

    def receive(msg=('vote',vote_info,c1)):
        c2=logical_clock()
        output("recieved vote in leader ",replica_id)
        proposal_msg,id=self.main.start_event_processing(vote_info,'vote_message')
        #print("proposal_msg, leader is ", leader)
        leader = None
        if id is not None:
          leader = nodes[id]
          #print()
        if proposal_msg and leader:
          output("got vote_info, leader")
          send(('proposal',proposal_msg,logical_clock()),to=ps)

    def run():
        #-- l1
        #if(self.main.workload_exists()):
        #while(1):
        if(self.main.can_send()):
          p, leader=self.main.process_new_round_event()
          output("sending messages to all processes from replica",replica_id)
          c=logical_clock()
          send(('proposal',p,c),to=ps)
          #-- l2
          await(len(setof(a,received(('proposal ack',c3), from_=a)))>2*f+1)
        #await(len(setof(a,received(('done',c3), from_=a)))>2*f+1)
        await(len(setof(a,received(('proposal ack',c3), from_=a)))>2*f+1)
        while(1):
          -- l3
        output("Replica ", replica_id," is terminaed")


def main():
    number_of_procs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    number_of_reqs = int(sys.argv[2]) if len(sys.argv) > 1 else 10
    f=(number_of_procs-1)/3
    all_replica_public_keys = []
    all_replica_private_keys = []

    for i in range(10):
      signing_key = SigningKey.generate()
      verify_key = signing_key.verify_key
      verify_key_b64 = verify_key.encode(encoder=HexEncoder)
      all_replica_public_keys.append(verify_key_b64)
      all_replica_private_keys.append(signing_key)

    all_client_public_keys = []
    all_client_private_keys = []

    for i in range(10):
      signing_key = SigningKey.generate()
      verify_key = signing_key.verify_key
      verify_key_b64 = verify_key.encode(encoder=HexEncoder)
      all_client_public_keys.append(verify_key_b64)
      all_client_private_keys.append(signing_key)

    ps = new(Replica, num= number_of_procs)
    i=0
    replica_map={}
    for p in ps:
        replica_map[i]=p
        i=i+1
    i=0
    for p in ps:
        setup(p, (i,replica_map,ps, f,number_of_reqs, all_replica_public_keys, all_client_public_keys, all_replica_private_keys[i]))
        i=i+1

    start(ps)
    await(len(setof(a, received(('done'), from_=a))) >= 2*f+1)
