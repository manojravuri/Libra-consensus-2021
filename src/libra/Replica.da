import os
import random
import string
import sys
import logging
import time
from collections import deque
from collections import defaultdict
from .Objects import *
import pickle
import threading
import random
import copy

config(clock = 'Lamport')
config(handling = 'all')

TIMEOUT=1

class Replica(process):
    def setup(replica_id:int,curr_pr,ps:list,f:int,number_of_requests:int):
    # ====== attributes of Replica ======
        output("creating replica ", replica_id)
        self.f = f
        self.replicas=ps
        self.proposals=set()
        self.number_of_requests = number_of_requests
        self.processing_req=False
        self.votes_received=0
        random.seed(6)
    # ====== attributes of Main ======
        self.replica_id = replica_id
        self.window_size = 1
        self.curr_pr = curr_pr

    # ====== attributes of MemPool ======
        self.q = deque()


    # ====== attributes of Ledger ======
        cur_path = os.getcwd()
        self.file_name = os.path.abspath(cur_path + "/../data/Ledger_" + str(self.replica_id) + ".txt")
        self.pending_map = {}
        self.committed_blocks = deque()  # committed block with window size
        self.ledger_state = ""

    # ====== attributes of Safety ======
        #self.private_key = private_key
        self.highest_vote_round = -1
        self.highest_qc_round = -1

    # ====== attributes of BlockTree ======
        self.pending_block_tree = set()
        self.pending_votes = {}
        vote_info = VoteInfo("block_id", -1, "parent_block_id", -2,"pending state of block_id")
        ledger_commit_info = LedgerCommitInfo(None,vote_info)
        signatures=[]
        for i in range (2*f+1):
            signatures.append(str(i+1)+"sign")
        self.high_commit_qc = QC(vote_info, ledger_commit_info,signatures,"-1","-1sign")
        #vote_info = VoteInfo("block_id", 1, "parent_block_id", 0,"pending state of block_id")
        #ledger_commit_info = LedgerCommitInfo(None,vote_info)
        self.high_qc = self.high_commit_qc


    # ====== attributes of PaceMaker ======
        self.current_round = 0
        self.last_round_tc = None
        self.pending_timeouts = None
        self.delta = 5
        self.timer = threading.Timer(None,None)

    # ====== attributes of LeaderElection ======
        self.exclude_size = f  # f to 2f
        self.reputation_leaders = {}

    # ====== methods of Main ======
    def Main_current_leader():
        return id == LeaderElection_get_leader()

    def Main_can_send():
        return LeaderElection_get_leader(self.current_round) == self.replica_id

    def Main_start_event_processing(M, type):
        #print("message in sep")
        print("LEADER in round",LeaderElection_get_leader(self.current_round),self.current_round )
        message = M
        if (type == 'local_timeout'):
            self.PaceMaker_local_timeout_round()
        if (type == 'proposal_message'):
            self.Main_process_proposal_msg(message)
        if (type == 'vote_message'):
            self.Main_process_vote_msg(message)
        if (type == 'timeout_mesaage'):
            self.Main_process_timeout_message(message)

    def Main_process_certificate_qc(qc):
        self.BlockTree_process_qc(qc)
        #print("process qc done")
        LeaderElection_update_leader(qc)
        #print("leader election done")
        self.PaceMaker_advance_round_qc(qc)
        #print("advance round done")

    def Main_process_proposal_msg(P):
        MemPool_pop_txns_on_proposal(P.block.payload)
        #print("processing certificate qc")
        self.Main_process_certificate_qc(P.block.qc)
        #print("processing high commit qc")
        self.Main_process_certificate_qc(P.high_commit_qc)
        #print("Advancing current round",self.current_round)
        self.PaceMaker_advance_round_tc(P.last_round_tc)
        #print("advanced round",self.current_round)
        round = self.current_round
        leader = LeaderElection_get_leader(round)
        #print(P.block.round)
        #print("curr_round",round)
        #print("sender",P.sender)

        if (P.block.round != round or P.sender != leader or P.block.author != leader):
            return
        #print(" before executed and inserted")

        self.BlockTree_execute_and_insert(P)
        #print("executed and inserted")
        vote_msg = self.Safety_make_vote(P.block, P.last_round_tc)
        #print("make vote done",vote_msg," if None no proposal")

        if vote_msg:
            print("sending votes to new leader, ", LeaderElection_get_leader(round + 1)," from ",replica_id)
            send( ('vote',vote_msg,logical_clock()), to=replicas[LeaderElection_get_leader(round + 1)])

    def Main_process_timeout_message(M):
        self.Main_process_certificate_qc(M.tmo_info.high_qc)
        self.Main_process_certificate_qc(M.high_commit_qc)
        self.PaceMaker_advance_round_tc(M.last_round_tc)
        tc = self.PaceMaker_process_remote_timeout(M)
        if (tc):
            self.PaceMaker_advance_round_qc(tc)
            self.process_new_round_event(tc)

    def Main_process_new_round_event(last_tc):

        output("NEW ROUND LEADER",replica_id,"ROUND",current_round)
        if replica_id == LeaderElection_get_leader(self.current_round):
            b = self.BlockTree_generate_block(replica_id, self.MemPool_get_transactions(), self.current_round)
            p = ProposalMsg(b, last_tc, self.high_commit_qc,replica_id)

            print("block b.author,b.round,b.payload,b.qc.vote_info.id,b.qc.signatures")
            print("broadcasting new block",b.author,b.round,b.payload,b.qc.vote_info.id,b.qc.signatures)

            #print("block id",b.id)
            #broadcast
            send(('proposal',p,logical_clock()),to=replicas)

    def Main_process_vote_msg(M):
        #print("process vote msg in main", M)
        qc = self.BlockTree_process_vote(M)
        #print("blocktree process qc done",qc,"if none no commit")
        if qc:
            self.Main_process_certificate_qc(qc)
            #print("here is it")
            self.Main_process_new_round_event(None)


    def Main_workload_exists():
        if (self.MemPool_get_transactions()):
            return True
        else:
            return False

    def Main_add_to_Mempool( M):
        self.MemPool_add_to_queue(M)


    # ====== methods of MemPool ======


    def MemPool_get_transactions():
        #print("Get Transactions")
        await(len(self.q))
        if len(self.q):
            a = self.q.popleft()
            self.q.appendleft(a)
            return a[1]
        return None

    def MemPool_increment_txn_start_num():
        #print("Popped from queue")
        self.q.popleft()
        return

    def MemPool_add_to_queue( M):
        #print("Added to queue in", M,replica_id)
        self.q.append(M)
        q_not_empty=True
        return

    def MemPool_pop_txns_on_proposal(txns):
        if len(self.q):
            a = self.q.popleft()[1]
            #print(a)
            if(a!=txns):
                self.q.appendleft(a)
        return




    # ====== methods of Ledger ======


    def Ledger_speculate(prev_block_id, block_id, block):
        self.pending_map[block_id] = {
            "prev_block_id": prev_block_id,
            "block": block,
        }
        pass

    def Ledger_pending_state(block_id):
        #print("ledger_pendmap",self.pending_map)
        #print("ledger_pendmap block id",block_id)
        return self.pending_map[block_id]["block"].payload

    def Ledger_commit(block_id):
        # update start txn after commit
        print("LEDGER ")
        #print(block_id)
        #print(self.pending_map,"in replica",replica_id)

        file = open(self.file_name, "a+")
        #print(self.pending_map[block_id]["block"].payload)
        file.write(self.pending_map[block_id]["block"].payload+" commited by "+str(replica_id)+" in round",str(current_round)+"\n")
        file.close()
        #print("persisted to ledger remember to use flsuh and fsync later in ",current_round,"by",replica_id)
        self.Ledger_add_committed_block_to_Q(block_id)
        self.ledger_state = self.ledger_state +"||"+ self.pending_map[block_id]["block"].payload
        #print(self.committed_blocks)
        #MemPool_pop_txns_if_committed(self.pending_map[block_id]["block"])
        #self.pending_map = {}
        # pass

    def Ledger_committed_block( block_id):
        for di in self.committed_blocks:
            if block_id in di:
                return di[block_id]
        return None

    def Ledger_add_committed_block_to_Q(block_id):
        if len(self.committed_blocks) == self.window_size:
            self.committed_blocks.popleft()
        self.committed_blocks.append(self.pending_map[block_id])


    # ====== methods of Safety ======


    def Safety_increase_highest_vote_round(round):
        self.highest_vote_round = max(round, self.highest_vote_round)

    def Safety_update_highest_qc_round( qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def Safety_consecutive( block_round, round):
        return round + 1 == block_round

    def Safety_safe_to_extend( block_round, qc_round, tc):
         if tc is None:
            return True
         output("Safety_safe_to_extend",qc_round,block_round,)
         return Safety_consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)

    def Safety_safe_to_vote( block_round, qc_round, tc):
        if (block_round <= max(self.highest_vote_round, qc_round)):
            return False
        return Safety_consecutive(block_round, qc_round) or Safety_safe_to_extend( block_round, qc_round, tc)

    def Safety_safe_to_timeout( round, qc_round, tc):
        if (qc_round < self.highest_qc_round or round <= max(self.highest_vote_round - 1, qc_round)):
            return False
        return Safety_consecutive( round, qc_round) or Safety_consecutive( round, tc.round)

    def Safety_commit_state_id_candidate(block_round, qc):
        if (Safety_consecutive(block_round, qc.vote_info.round) and qc.vote_info.round>=0):
            #print("QC_vid",qc.vote_info.id)
            return Ledger_pending_state(qc.vote_info.id)
        else:
            return None

    def Safety_valid_signatures( high_qc, last_tc):
        return True

    def Safety_make_vote( b, last_tc):
        qc_round = b.qc.vote_info.round
        #print("BLOck round",b.round)
        #print("QC round",qc_round)
        #print("last_tc",last_tc)
        #print("last tc round",last_tc.round)

        #print("stv=",Safety_safe_to_vote(b.round, qc_round, last_tc))
        if self.Safety_valid_signatures(b, last_tc) and Safety_safe_to_vote(b.round, qc_round, last_tc):
            self.Safety_update_highest_qc_round(qc_round)
            self.Safety_increase_highest_vote_round(b.round)
            vote_info = VoteInfo(b.id, b.round, b.qc.vote_info.id, qc_round,Ledger_pending_state(b.id))
            ledger_commit_info = LedgerCommitInfo(Safety_commit_state_id_candidate(b.round,b.qc), vote_info)
            return VoteMsg(vote_info, ledger_commit_info, high_commit_qc, replica_id, str(replica_id)+"sign")
        return None

    def Safety_make_timeout( round, high_qc, last_tc):
        qc_round = high_qc.vote_info.round
        if (self.Safety_valid_signatures(high_qc, last_tc) and self.Safety_safe_to_timeout(round, qc_round, last_tc)):
            return TimeoutInfo(round, high_qc)
        return None

    # ====== methods of BlockTree ======


    def BlockTree_process_qc(qc):
        #print("ledger commit info id in qc--->",qc.ledger_commit_info.commit_state_id)
        #print("current_round",current_round)
        if qc.ledger_commit_info.commit_state_id:
           # print("writtent id in qc",qc.vote_info.parent_id)
            self.Ledger_commit(qc.vote_info.parent_id)
            # prune branches
            # self.pending_block_tree.prune(qc.vote_info_parent_id)
            self.high_commit_qc = self.BlockTree_get_max_QC(qc, self.high_commit_qc)
        self.high_qc = self.BlockTree_get_max_QC(qc, self.high_qc)
        # print("process qc done")

    def BlockTree_execute_and_insert(P):
        # print(b)
        self.Ledger_speculate(P.block.qc.vote_info.id, P.block.id, P.block)
        self.pending_block_tree.add(P.block)

    def BlockTree_process_vote(v):
        #print("in process_vote ", v)
        self.BlockTree_process_qc(v.high_commit_qc)

        vote_idx = str(v.ledger_commit_info.commit_state_id)+"||"+str(v.ledger_commit_info.vote_info_hash)

        if vote_idx not in pending_votes:
            self.pending_votes[vote_idx]=[]
        self.pending_votes[vote_idx].append(v.signature)
        #print("pending_votes vote_idx is , ", self.pending_votes)
        #print("self.pending_votes ", self.pending_votes)
        #print(len(self.pending_votes[vote_idx]),(2 * self.f + 1),"--",(len(self.pending_votes[vote_idx]) == (2 * self.f + 1)))
        if (len(self.pending_votes[vote_idx]) == (2 * self.f + 1)):
            #print('before QUC')
            qc = QC(vote_info=v.vote_info, ledger_commit_info=v.ledger_commit_info, signatures=self.pending_votes[vote_idx]
            ,author=replica_id ,author_signature=str(replica_id)+"sign")

            #print("QuorumC in round",current_round,"by", qc.author,"and signed by",self.pending_votes[vote_idx])
            return qc
        return None

    def BlockTree_generate_block(u, txns, current_round):
        return Block(author=u, round=current_round, payload=txns, qc=self.high_qc)

    def BlockTree_get_max_QC(qc1, qc2):
        #print("qc1",qc1.vote_info.round)
        #print("qc2", qc2.vote_info.round)
        maxQC = qc1 if (qc1.vote_info.round > qc2.vote_info.round) else qc2
        return maxQC

    # ====== methods of PaceMaker ======


    def PaceMaker_stop_timer(round):
        self.timer.cancel()
        pass

    def PaceMaker_get_round_timer( r):
        # c=logical_clock()
        return 4 * self.delta

    def PaceMaker_start_timer(new_round):
        # self.PaceMaker_stop_timer(self.current_round)

        #print("round updated to ",new_round)
        #print("XOX replica",replica_id," has new leader",LeaderElection_get_leader(self.current_round),"in rnd",self.current_round)
        self.current_round = new_round
        self.timer = threading.Timer(self.PaceMaker_get_round_timer(1), self.PaceMaker_local_timeout_round)
        self.timer.start()
        # return self.PaceMaker_get_round_timer( self.current_round)

    def PaceMaker_local_timeout_round():
        # save_consensus_state()
        #print("local timeout")
        self.PaceMaker_stop_timer(self.current_round)
        timeout_info = self.Safety_make_timeout(self.current_round, self.high_qc, self.last_round_tc)
        print("broadcast Timeout to Replicas")
        # broadcast TimeoutMsg(timeout_info,self.last_round_tc,self.high_commit_qc)

    def PaceMaker_process_remote_timeout( tmo):
        tmo_info = tmo.tmo_info
        if (tmo_info.round < self.current_round):
            return None
        if (tmo_info.sender not in self.pending_timeouts):
            self.pending_timeouts.add(tmo_info)
        if (self.pending_timeouts.size() == f + 1):
            self.PaceMaker_stop_timer(self.current_round)
            self.PaceMaker_local_timeout_round()
        if (self.pending_timeouts.size() == 2 * f + 1):
            round = tmo_info.round
            tmo_high_qc_rounds = self.pending_timeouts[tmo_info.round][0].high_qc.round
            signatures = self.pending_timeouts[tmo_info.round][0].signature
        return None

    def PaceMaker_advance_round_tc(tc):
        #print("advance rond TC")
        if tc is None or tc.round < self.current_round:
            return False
        self.last_round_tc = tc
        self.PaceMaker_start_timer(tc.round + 1)
        return True

    def PaceMaker_advance_round_qc( qc):
        #print("advance rond QC")
        if qc.vote_info.round < self.current_round:
            return False
        self.last_round_tc = None
        self.PaceMaker_start_timer(qc.vote_info.round + 1)
        return True


    # ====== methods of LeaderElection ======


    def LeaderElection_elect_reputation_leader(qc):
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while (i < self.window_size) : #or ( (len(last_authors) < self.exclude_size)

            current_block = self.Ledger_committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author if current_block else None
            if i < self.window_size:
                active_validators=set.union(active_validators,set(get_replica_ids(current_qc.signatures)))
            if (len(last_authors) < self.exclude_size) and block_author:
                last_authors.add(block_author)
            if current_block:
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        #print("active_validators in replica_id ",replica_id,"-->",active_validators,self.current_round)
        active_validators=list(active_validators)
        return active_validators[0]  # random.randint(0, len(active_validators) - 1)

    def LeaderElection_update_leader(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = self.current_round

        if extended_round + 1 == qc_round and qc_round + 1 == current_round:
            #print("updated leader rep", current_round + 1," for ", self.LeaderElection_elect_reputation_leader(qc))
            self.reputation_leaders[current_round + 1] = self.LeaderElection_elect_reputation_leader(qc)

    def LeaderElection_get_leader(round):
        #print("round in rep_leaders",self.reputation_leaders)
        if self.reputation_leaders and round in self.reputation_leaders:
            return self.reputation_leaders[round]
        return int((round / 2) % len(replicas))

    def get_replica_ids(signatures):
        rps=[]
        for sign in signatures:
            sign=str(sign).strip('sign')
            rps.append(int(sign))

        #print("sign",rps)
        return rps




    # ====== methods of Validator ======


    def receive(msg=('proposal',p1,c1)):
        c2=logical_clock()
        output("recieved proposal message in",replica_id)
        send(('proposal ack',c2), to=replicas)
        self.Main_start_event_processing(p1,'proposal_message')


    def receive(msg=('vote',vote_info,c1)):
        #check if received replica is leader using PaceMaker
        print("votes received before check",votes_received)
        if received_suf_votes():
            return
        output("votes_received",votes_received," in replica",replica_id)
        votes_received = votes_received + 1
        c2=logical_clock()
        output("recieved vote in leader ",replica_id)
        self.Main_start_event_processing(vote_info,'vote_message')


    def receive(msg=('request',cmd,c,p)):
        output("message received "+str(cmd)+" from "+str(p)+" at "+str(replica_id))
        M=('request',cmd,c)
        self.Main_add_to_Mempool(M)

    def run():
        #handle first round
        time.sleep(5)
        if(self.Main_can_send()):
            #output("sending messages to all processes from replica",replica_id)
            self.Main_process_new_round_event(TC(-10))
            -- l2
           # processed_votes=0

        while(1):  # keep replica always running
            -- handlemessages
            if(self.Main_can_send()):

                while(votes_received<=2*f+1):
                    --  handlevotes   #handle 2f+1 votes before

        output("Replica ", replica_id," is terminated")


    def received_suf_votes():
        return votes_received>=2*f+1

